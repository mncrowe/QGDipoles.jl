var documenterSearchIndex = {"docs":
[{"location":"Examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Here we present some examples which demonstrate how to use this package. Further examples are available in the examples/ directory here.","category":"page"},{"location":"Examples/#Example-1:-1-layer-QG","page":"Examples","title":"Example 1: 1-layer QG","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Let's calculate and plot the Larichev-Reznik dipole (LRD). This diople exists on the beta-plane in the equivalent barotropic model so we take beta = R = 1 and consider a 1-layer solution (N = 1). We'll also assume unit radius and velocity, ell = U = 1. Let's start by loading the package and defining some parameters.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"using QGDipoles\n\n# Set problem parameters\n\nU, ℓ = 1, 1\t# vortex speed and radius\nR = 1\t\t# Rossby radius in each layer\nβ = 1\t\t# background PV gradient in each layer\n\nM = 8\t\t# number of coefficients in Zernike expansion\ntol = 1e-8\t# maximum error in solution evaluation\n\n# Set grid parameters\n\nNx, Ny = 512, 512\nLx, Ly = 10, 10\n\nnothing","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"We've taken M = 8 as this is generally a sufficient number of terms to get a relative error  10^-6 in the final result. The tolerance, tol, is used in calculating the terms in the linear system and a value of tol=10^{-8} corresponds to approximately the same error as our chosen M value. We're also going to build a grid with 512 points in each direction and have taken the grid size to be 10 in each direction, which is sufficient to capture the far-field decay of the vortex. We can now build the linear system and solve for the coefficients as follows:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# Build and solve linear system for coefficients\n\nλ = ℓ / R\nμ = β * ℓ^2/U\n\nA, B, c, d = BuildLinSys(M, λ, μ; tol)\nK, a = SolveInhomEVP(A, B, c, d; K₀ = 4, tol)\n\nnothing","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The intermediate parameters, lambda and mu, describe the rescaled vortex radius and PV gradient. Finally, we can define a grid and evaluate our streamfunction, PV and velocities using:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# Create grid and calculate streamfunctions and vorticities\n\ngrid = CreateGrid(Nx, Ny, Lx, Ly)\nψ, q = Calc_ψq(a, U, ℓ, R, β, grid)\nu, v = Calc_uv(ψ, grid)\n\nnothing","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"We can plot our solution using Plots.jl:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"using Plots\n\nheatmap(grid.x, grid.y, transpose(ψ[:,:,1]);\n    colormap = :balance,\n    aspect_ratio=1,\n    xlims = (-Lx/2, Lx/2),\n    ylims = (-Ly/2, Ly/2),\n    xlabel = \"x\",\n    ylabel = \"y\")\n","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Note that we transpose psi when plotting as x corresonds to the first dimension of psi.","category":"page"},{"location":"Examples/#Example-2:-multi-layer-QG","page":"Examples","title":"Example 2: multi-layer QG","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"This example considers a 3-layer solution and introduces the concept of active and passive layers. We define an active layer to be a layer with a closed streamline at x^2 + y^2 = ell^2 whereas a passive layer has no closed streamlines. Therefore, fluid within the vortex in an active layer remains trapped in the vortex. Conversely, fluid in the passive layer is not trapped in a vortex core but can still be affected through the change in layer thickness associated with the streamfunction in neighbouring layers. Passive layers have F_i(z) = (beta_iU) z everywhere and hence have no eigenvalue, K_i, to solve for. Further, the coefficients within a passive layer are zero though the solution may still be non-zero due to the coefficients in neighbouring layers. Therefore, the corresponding linear system can be simplified by removing rows and columns corresponding to passive layers and solving the reduced system for the active layers only.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"We'll start by defining some parameters:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"using QGDipoles\n\n# Set problem parameters\n\nU, ℓ = 1, 1\t\t\t# vortex speed and radius\nR = [1, 1, 1]\t\t\t# Rossby radius in each layer\nβ = [0, 0, 1]\t\t\t# background PV gradient in each layer\nActiveLayers = [0, 1, 0]\t# 1 => layer contains vortex region\nx₀ = [5, 5]\t\t\t# location of vortex center\n\nM = 8\t\t\t\t# number of coefficients in Zernike expansion\ntol = 1e-8\t\t\t# maximum error in solution evaluation\n\n# Set grid parameters\n\nNx, Ny = 512, 512\nLx, Ly = [0, 10], [0, 10]\n\nnothing","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"We've assumed that only the middle layer is active. Therefore our solution will describe a mid-depth propagating structure. We've also taken a background PV gradient in the lower layer only, to represent, say, a topographic slope. Finally, we've taken our vortex to be centred at 5 5 and taken x and y to run from 0 to 10.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"We start by building the full linear system:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# Build and solve linear system for coefficients\n\nλ = ℓ ./ R\nμ = β * ℓ^2/U\n\nA, B, c, d = BuildLinSys(M, λ, μ; tol)\n\nnothing","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Next we remove the passive layers:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"A, B, c, d = ApplyPassiveLayers(A, B, c, d, ActiveLayers)\n\nnothing","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"We can now solve the reduced system and put the passive layers, which have (K textbfa) = (0 textbf0), back in to ensure the sizes of K and textbfa match the number of layers:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"K, a = SolveInhomEVP(A, B, c, d; K₀ = 4, tol)\nK, a = IncludePassiveLayers(K, a, ActiveLayers)\n\nnothing","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Finally, we can calculate our solution:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# Create grid and calculate streamfunctions and vorticities\n\ngrid = CreateGrid(Nx, Ny, Lx, Ly)\nψ, q = Calc_ψq(a, U, ℓ, R, β, grid, x₀)\n\nnothing","category":"page"},{"location":"Examples/#Example-3:-SQG","page":"Examples","title":"Example 3: SQG","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"This example covers the SQG vortex and introduces grids on a GPU. We'll start by defining some parameters. There are a few changes here compared to the LQG setup. Firstly, we'll need to set the flag sqg to true as the linear system is different in the SQG case and the functions assume LQG by default. Also, despite the SQG problem having only 1-layer, we enter R as a 2 element vector since we need both the (reduced) barotropic and baroclinic Rossby radii, R and R. We'll take these as infty using Int and note that these functions accept infinite Rossby radii in both the SQG and LQG cases. However, R = 0 is not valid since the QG assumptions break down in this limit. Note that we take M = 20 here and in general we'll need more coefficients for the SQG problem compared to the LQG problem as they decay slower with coefficient number. This is compensated by the fact that the SQG system is faster to calculate than the LQG system.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"using QGDipoles\n\n# Set problem parameters\n\nU, ℓ = 1, 1     \t# vortex speed and radius\nR = [Inf, Inf]\t\t# Baroclinic and Barotropic Rossby radii\nβ = 0\t\t    \t# background PV gradient in the interior\n\nM = 20\t\t    \t# number of coefficients in Zernike expansion\ntol = 1e-6\t    \t# maximum error in solution evaluation\ncuda = false\t\t# use CuArrays for grid\nmethod = 0\t    \t# 0; eigensolve/nlsolve, 1; nlsolve\nsqg = true\t    \t# functions use SQG functionality\n\n# Set grid parameters\n\nNx, Ny = 512, 512\nLx, Ly = 10, 10\n\nnothing","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"We have introduced a couple of new variables here. Firstly, cuda is a flag that is passed to the grid object and when set to true will create the grid on an available GPU. Secondly, method is passed to the linear system solver, SolveInhomEVP, and determines if root-finding is used as the default method (method = 1) or if the problem is solved by eigenvalue methods for the 1-layer LQG and SQG problems (method = 0). In general, method = 0 should be used, but if you have a good initial guess for K and textbfa, it may be faster to use method = 1.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Next we can build the linear system:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# Build and solve linear system for coefficients\n\nλ = ℓ ./ R\nμ = β * ℓ^2/U\n\nA, B, c, d = BuildLinSys(M, λ, μ; tol, sqg)\nK, a = SolveInhomEVP(A, B, c, d; K₀ = 4, tol, method, sqg)\n\nnothing","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"And finally we can create our solution:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# Create grid and calculate streamfunctions and vorticities\n\ngrid = CreateGrid(Nx, Ny, Lx, Ly; cuda)\nψ, b = Calc_ψb(a, U, ℓ, R, β, grid)\nu, v = Calc_uv(ψ, grid)\n\nnothing","category":"page"},{"location":"Examples/#Example-4:-Wrappers","page":"Examples","title":"Example 4: Wrappers","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"While the procedure outlined in Examples 1 to 3 gives an understanding our how this method works, it is often easier for users to be able to just call a single function to get the solution they want. Therefore, this package also includes wrappers for the SQG and LQG problems. Let's start with the LQG case and define some parameters:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"using QGDipoles\n\n# Set problem parameters\n\nU, ℓ = 1, 1\t\t\t# vortex speed and radius\nR = [1, 1]\t\t\t# Rossby radius in each layer\nβ = [0, 1]\t\t\t# background PV gradient in each layer\nActiveLayers = [1, 1]\t\t# 1 => layer contains vortex region\nx₀ = [0, 0]\t\t\t# position of vortex center\n\nM = 8\t\t\t\t# number of coefficients in Zernike expansion\ntol = 1e-8\t\t\t# maximum error in solution evaluation\ncuda = false\t\t\t# use CuArrays for grid\nK₀, a₀ = [4, 4], nothing\t# guesses for K and a\n\n# create grid\n\nNx, Ny = 512, 512\nLx, Ly = 10, 10\n\ngrid = CreateGrid(Nx, Ny, Lx, Ly; cuda)\n\nnothing","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Most of these have been described in previous examples, but K_0 and textbfa_0 are new. These are the initial guesses for K and textbfa and are not required. They can be useful when doing a parameter sweep; since values from a case with similar parameters can be used to speed up the root-finding step for the new parameter case. In general, K = 4 is a good guess for most LQG and SQG vortices. In principle, there are a (countably) infinite set of solutions with increasing radial mode number. The solutions we normally think of as dipolar vortices are the first mode and higher modes are generally unstable[1].","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Now we have our parameters, we can get our vortex solution with a single function call:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# create modon solution\n\nψ, q, K, a = CreateModonLQG(grid, M, U, ℓ, R, β, ActiveLayers, x₀; K₀, a₀, tol)\n\nnothing","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The SQG wrapper is similar. We start by defining our paramters:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# Set problem parameters\n\nU, ℓ = 1, 1\t\t\t# vortex speed and radius\nR = [Inf, Inf]\t\t\t# Baroclinic and Barotropic Rossby radii\nβ = 0\t\t\t\t# background PV gradient in the interior\nx₀ = [0, 0]\t\t\t# position of vortex center\n\nM = 20\t\t\t\t# number of coefficients in Zernike expansion\ntol = 1e-6\t\t\t# maximum error in solution evaluation\ncuda = false\t\t\t# use CuArrays for grid\nK₀, a₀ = 8, nothing\t\t# guesses for K and a\n\n# Set grid parameters\n\nNx, Ny = 512, 512\nLx, Ly = 10, 10\n\n# create grid\n\ngrid = CreateGrid(Nx, Ny, Lx, Ly; cuda)\n\nnothing","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Note that we've used K_0 = 8 this time. We'll see what happens when we create and plot our solution:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# create modon solution\n\nψ, b, K, a = CreateModonSQG(grid, M, U, ℓ, R, β, x₀; K₀, a₀, tol)\n\nK","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"using Plots\n\nheatmap(grid.x, grid.y, transpose(ψ);\n    colormap = :balance,\n    aspect_ratio=1,\n    xlims = (-Lx/2, Lx/2),\n    ylims = (-Ly/2, Ly/2),\n    xlabel = \"x\",\n    ylabel = \"y\")","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"If we look at K, we find that K approx 734205 which is not the value we'd expect for the usual dipole solution. Instead, if we look at our plot, we see that it's a different solution with a mode 2 structure in the radial direction.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"In addition to these wrapper functions, the functions CreateLCD and CreateLCD implement the Lamb-Chaplygin dipole[2] and Larichev-Reznik dipole[3] directly using the analytical solution for these cases.","category":"page"},{"location":"Examples/#Example-5:-A-GeophysicalFlows.jl-simulation","page":"Examples","title":"Example 5: A GeophysicalFlows.jl simulation","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"This package is designed to be compatible with GeophysicalFlows.jl[4] and provide a means of generating dipolar vortex initial conditions for layered QG and surface QG simulations. Here, we'll discuss a simple example of how to setup a 1-layer simulation in GeophyiscalFlows.jl using the Lamb-Chaplygin dipole as the initial condition. We'll also see that, as expected, the dipole retains it's form during the evolution and hence is a steady solution in a co-moving frame. Let's begin by defining some parameters for our vortex initial condition and our numerical simulation:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"using GeophysicalFlows, QGDipoles\n\n# Define vortex parameters\n\nU, ℓ = 1, 1\n\n# Set numerical simulation parameters\n\nnx, ny = 1024, 1024\nLx, Ly = 20.48, 20.48\nT = 10                        # simulation stop time\nΔt = 0.01                     # timestep\nNt = Int(T/Δt)\t\t\t\t  # number of timesteps\ndev = GPU()\nstepper = \"FilteredRK4\"\n","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"GeophysicalFlows.jl allows simulations to be run on a GPU so we've set dev = CPU() to use this functionality. QGDipoles.jl will construct vortex solutions as CuArrays using CUDA when given a grid that is stored on a GPU. We can now define our problem using the SingleLayerQG module from GeophysicalFlows.jl. This problem will contain a grid (prob.grid) that can be passed to functions from QGDipoles.jl in the same manner as grids contructed using CreateGrid.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# Define problem using SingleLayerQG from GeophysicalFlows.jl\n\nprob = SingleLayerQG.Problem(dev;\n\t\tnx,\n\t\tny,\n\t\tLx,\n\t\tLy,\n\t\tU = -U,\t\t\t# background flow so vortex remains stationary\n\t\tdt = Δt,\n\t\tstepper)\n","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Here, we've used a background flow which moves in the opposite direction to the vortex and with the same magnitude, U. Therefore, we're working in a frame co-moving with the vortex and we expect it to remain centred on the orogin throughout the evolution. Next, we'll use CreateLCD to create a Lamb-Chaplygin dipole and use this as our initial condition.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# Set initial condition\n\n_, q₀, K = CreateLCD(prob.grid, U, ℓ)\nq₀ = reshape(q₀, nx, ny)\t\t# convert from size (nx, ny, 1) to size (nx, ny)\nSingleLayerQG.set_q!(prob, q₀)\n\n# Define Energy as a diagnostic for the simulation\n\ndiags = Diagnostic(SingleLayerQG.energy, prob; nsteps=Nt, freq=Int(Nt/100))\n","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"We've also defined a Diagnostic which will save the domain-averaged energy during the simulation. Finally, we can evolve the simulation in time:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# Evolve system forward in time\n\nstepforward!(prob, diags, Nt)\nSingleLayerQG.updatevars!(prob)\n","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"We can plot our initial condition and solution at t = 100 using:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"using Plots\n\nplot(heatmap(prob.grid.x, prob.grid.y, device_array(CPU())(transpose(q₀));\n\tcolormap = :balance,\n\taspect_ratio=1,\n\txlims= (-Lx/2, Lx/2),\n\tylims = (-Ly/2, Ly/2),\n\txlabel = \"x\",\n\tylabel = \"y\"),\n     heatmap(prob.grid.x, prob.grid.y, device_array(CPU())(transpose(prob.vars.q));\n\tcolormap = :balance,\n\taspect_ratio=1,\n\txlims= (-Lx/2, Lx/2),\n\tylims = (-Ly/2, Ly/2),\n\txlabel = \"x\",\n\tylabel = \"y\"))\n","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Note that we need to move our fields back to the CPU prior to plotting. The two plots are shown below and are approximately identical. Therefore, we observe that the vortex remains centred at the origin. Over long times, numerical error will result in the vortex moving at a slightly different speed to U and hence moving away from the origin.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"(Image: image)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"See the GeophyiscalFlows.jl documentation here for more details on how to run QG simulations.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"[1]: Johnson, E. R., and M. N. Crowe, 2023, Oceanic dipoles in a surface quasigeostrophic model, J. Fluid Mech., 958, R2.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"[2]: Lamb, H., 1932, Hydrodynamics. Cambridge University Press.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"[3]: Larichev, V.D. & Reznik, G.M., 1976, Two-dimensional solitary Rossby waves, Dokl. Akad. Nauk SSSR, 12–13.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"[4]: Constantinou et al., 2021, GeophysicalFlows.jl: Solvers for geophysical fluid dynamics problems in periodic domains on CPUs & GPUs, JOSS, 6(60), 3053.","category":"page"},{"location":"Functions/#Functions","page":"List of Functions","title":"Functions","text":"","category":"section"},{"location":"Functions/","page":"List of Functions","title":"List of Functions","text":"This page lists all Modules, Functions and Structures available in this package.","category":"page"},{"location":"Functions/#QGDipoles.jl","page":"List of Functions","title":"QGDipoles.jl","text":"","category":"section"},{"location":"Functions/","page":"List of Functions","title":"List of Functions","text":"QGDipoles","category":"page"},{"location":"Functions/#QGDipoles","page":"List of Functions","title":"QGDipoles","text":"Package for creating steady modon solutions to the layered quasi-geostrophic equations and the surface quasi geostrophic equations.\n\nSee examples/ for example scripts and here for documentation.\n\n\n\n\n\n","category":"module"},{"location":"Functions/#JJ_integ.jl","page":"List of Functions","title":"JJ_integ.jl","text":"","category":"section"},{"location":"Functions/","page":"List of Functions","title":"List of Functions","text":"A_func\nB_func\nJJ_int","category":"page"},{"location":"Functions/#QGDipoles.A_func","page":"List of Functions","title":"QGDipoles.A_func","text":"Function: A_func(ξ, λ, μ)\n\nEvaluates the matrix function A(ξ, λ, μ) = K(ξ) [K(ξ) + D(μ)]⁻¹ ξ⁻¹\n\nArguments:\n\nξ: point in [0, ∞), Number\nλ: ratio of vortex radius to Rossby radius in each layer, Number or Vector\nμ: nondimensional (y) vorticity gradient in each layer, Number or Vector\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.B_func","page":"List of Functions","title":"QGDipoles.B_func","text":"Function: B_func(ξ, λ, μ)\n\nEvaluates the matrix function B(ξ, λ, μ) = [K(ξ) + D(μ)]⁻¹ ξ⁻¹\n\nArguments:\n\nξ: point in [0, ∞), Number\nλ: ratio of vortex radius to Rossby radius in each layer, Number or Vector\nμ: nondimensional (y) vorticity gradient in each layer, Number or Vector\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.JJ_int","page":"List of Functions","title":"QGDipoles.JJ_int","text":"Function: JJ_int(F, j, k, tol=1e-6)\n\nEvaluates the integral I = int_0^infty F(xi) J_2j+2(xi) J_2k+2(xi) mathrmdxi\n\nArguments:\n\nF: function to integrate, typically A_func or B_func, Function\nj: first Bessel function index, Integer\nk: second Bessel function index, Integer\ntol: error tolerance for QuadGK, Number (default: 1e-6)\n\nNote: This integral is performed by deforming the contour of integration into the complex plane where the Bessel function decays exponentially in the imaginary direction.\n\n\n\n\n\n","category":"function"},{"location":"Functions/#lin_sys.jl","page":"List of Functions","title":"lin_sys.jl","text":"","category":"section"},{"location":"Functions/","page":"List of Functions","title":"List of Functions","text":"BuildLinSys\nApplyPassiveLayers\nIncludePassiveLayers\nSolveInhomEVP\nInhomEVP_F!\nOrthogSpace","category":"page"},{"location":"Functions/#QGDipoles.BuildLinSys","page":"List of Functions","title":"QGDipoles.BuildLinSys","text":"Function: BuildLinSys(M, λ, μ; tol=1e-6, sqg=false)\n\nBuilds the terms in the inhomogeneous eigenvalue problem; A, B, c, d\n\nArguments:\n\nM: number of coefficient to solve for, Integer\nλ: ratio of vortex radius to Rossby radius in each layer, Number or Vector\nμ: nondimensional (y) vorticity gradient in each layer, Number or Vector\ntol: error tolerance for QuadGK via JJ_int, Number (default: 1e-6)\nsqg: false; creates layered QG system, true; creates SQG system (default: false)\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.ApplyPassiveLayers","page":"List of Functions","title":"QGDipoles.ApplyPassiveLayers","text":"Function: ApplyPassiveLayers(A, B, c, d, ActiveLayers)\n\nRemoves rows and columns corresponding to passive layers from the system\n\nArguments:\n\nA, B, c, d: inhomogeneous eigenvalue problem terms, Arrays\nActiveLayers: vector of 1s or 0s where 1 denotes an active layer, Number or Vector\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.IncludePassiveLayers","page":"List of Functions","title":"QGDipoles.IncludePassiveLayers","text":"Function: IncludePassiveLayers(K, a, ActiveLayers)\n\nIncludes columns corresponding to passive layers in the eigenvalue and coefficient arrays\n\nArguments:\n\nK, a: eigenvalue and coefficient arrays describing system solution, Arrays\nActiveLayers: vector of 1s or 0s where 1 denotes an active layer, Number or Vector\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.SolveInhomEVP","page":"List of Functions","title":"QGDipoles.SolveInhomEVP","text":"Function: SolveInhomEVP(A, B, c, d; K₀=nothing, a₀=nothing, tol=1e-6, method=0, m=2, sqg=false, warn=true)\n\nSolves the inhomogeneous eigenvalue problem using nonlinear root finding\n\nArguments:\n\nA, B, c, d: inhomogeneous eigenvalue problem terms, Arrays\nK₀, a₀: initial guesses for K and a, Arrays or nothings (default: nothing)\ntol: error tolerance for nlsolve, Number (default: 1e-6)\nmethod: 0 - eigensolve for N = 1 and nlsolve for N > 1, 1 - nlsolve (default: 0)\nm: exponent of K in eignevalue problem (default: 2)\nsqg: false, uses m value specified; true, sets m=1 (default: false)\nwarn: if true displays warning if solution includes unextracted passive layers (default: true)\n\nNote: setting sqg=true overwrites the value of m and is equivalent to setting m=1. The option to set both is included for consistency with BuildLinSys and more generality with the value of m.\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.InhomEVP_F!","page":"List of Functions","title":"QGDipoles.InhomEVP_F!","text":"Function: InhomEVP_F!(F, J, x, A, B, c, d, e)\n\nCalculates the function F and it's derivatives, J, at a given point x\n\nArguments:\n\nF, J: values of F and it's derivatives, updated by function\nx: evaluation point, Array\nA, B, c: inhomogeneous eigenvalue problem terms, Arrays\ne: basis spanning the space perpendicular to the d[n], Array\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.OrthogSpace","page":"List of Functions","title":"QGDipoles.OrthogSpace","text":"Function: OrthogSpace(v)\n\nExtends the input to an orthonormal basis over R^n using the Gram-Schmidt method\n\nArguments:\n\nv: array with vectors as columns, Array\n\n\n\n\n\n","category":"function"},{"location":"Functions/#create_modon.jl","page":"List of Functions","title":"create_modon.jl","text":"","category":"section"},{"location":"Functions/","page":"List of Functions","title":"List of Functions","text":"ZernikeR\nGridStruct\nCreateGrid\nCalc_ψq\nCalc_ψb\nCalc_uv\nΔNCalc\nCreateModonLQG\nCreateModonSQG\nCreateLCD\nCreateLRD\nEval_ψ_SQG\nEval_q_SQG\nEval_b_SQG\nEval_w_SQG\nCalc_∇\nCartesianGrid\nPolarGrid\nCalc_ζ","category":"page"},{"location":"Functions/#QGDipoles.ZernikeR","page":"List of Functions","title":"QGDipoles.ZernikeR","text":"Function: ZernikeR(n, x)\n\nDefine the Zernike radial function using the jacobi function from SpecialFunctions\n\nArguments:\n\nn: order, Integer\nx: evaluation point, Number or Array\n\nNote: this function is defined on [-1, 1] and is set to 0 for |x| > 1\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.GridStruct","page":"List of Functions","title":"QGDipoles.GridStruct","text":"Structure: GridStruct\n\nStores the grid variables in physical and Fourier space\n\nArguments:\n\nx, y: x and y points in physical space, Ranges\nkr, l: x and y points in Fourier space, Arrays\nKrsq: kr²+l² in Fourier space, Array\n\n\n\n\n\n","category":"type"},{"location":"Functions/#QGDipoles.CreateGrid","page":"List of Functions","title":"QGDipoles.CreateGrid","text":"Function: CreateGrid(Nx, Ny, Lx, Ly; cuda=false)\n\nDefine the numerical grid as a GridStruct\n\nArguments:\n\nNx, Ny: number of gridpoints in x and y directions, Integers\nLx, Ly: x and y domains, either vectors of endpoints or lengths, Vectors or Numbers\ncuda: true; use CUDA CuArray for fields (default: false)\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.Calc_ψq","page":"List of Functions","title":"QGDipoles.Calc_ψq","text":"Function: Calc_ψq(a, U, ℓ, R, β, grid, x₀=[0, 0], α=0)\n\nCalculate ψ and q in a layered QG model using coefficients and vortex parameters\n\nArguments:\n\na: M x N array of coefficients, Array\n(U, ℓ): vortex speed and radius, Numbers\n(R, β): Rossby radii and (y) PV gradients in each layer, Numbers or Vectors\ngrid: grid structure containing x, y, and Krsq\nx₀: position of vortex center, vector (default: [0, 0])\nα: initial angle of vortex, Number (default: 0)\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.Calc_ψb","page":"List of Functions","title":"QGDipoles.Calc_ψb","text":"Function: Calc_ψb(a, U, ℓ, R, β, grid, x₀=[0, 0], α=0)\n\nCalculate SQG fields ψ and b using coefficients and vortex parameters\n\nArguments:\n\na: M x 1 array of coefficients, Array\n(U, ℓ): vortex speed and radius, Numbers\nR: vector of [R, R'], Vector\nβ: beta-plane (y) PV gradient, Number\ngrid: grid structure containing x, y, and Krsq\nx₀: position of vortex center, vector (default: [0, 0])\nα: initial angle of vortex, Number (default: 0)\n\nNote: Here R is the baroclinic Rossby radius, R = NH/f, and R' = R₀²/R where R₀ is the barotropic Rossby radius, R₀ = √(gH)/f. For infinite depth, R' = g/(fN).\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.Calc_uv","page":"List of Functions","title":"QGDipoles.Calc_uv","text":"Function: Calc_uv(ψ, grid)\n\nCalculate the velocity fields from ψ using (u, v) = (-∂ψ/∂y, ∂ψ/∂x)\n\nArguments:\n\nψ: streamfunction, Array\ngrid: grid structure containing kr and l\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.ΔNCalc","page":"List of Functions","title":"QGDipoles.ΔNCalc","text":"Function: ΔNCalc(K², R, β, U=1)\n\nDefines the Δ_N(β) matrix used to invert for ψ and q\n\nArguments:\n\nK²: value of k²+l² in Fourier space, Array\n(R, β): Rossby radii and (y) PV gradients in each layer, Numbers or Vectors\nU: vortex speed, Number (default: 1)\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.CreateModonLQG","page":"List of Functions","title":"QGDipoles.CreateModonLQG","text":"Function: CreateModonLQG(grid, M, U=1, ℓ=1, R=1, β=0, ActiveLayers=1, x₀=[0, 0], α=0; K₀=nothing, a₀=nothing, tol=1e-6)\n\nHigh level wrapper function for calculating ψ and q for the Layered QG model using given parameters\n\nArguments:\n\ngrid: grid structure containing x, y, and Krsq\nM: number of coefficient to solve for, Integer (default: 8)\n(U, ℓ): vortex speed and radius, Numbers (default: (1, 1))\n(R, β): Rossby radii and (y) PV gradients in each layer, Numbers or Vectors, (default: (1, 0))\nActiveLayers: vector of 1s or 0s where 1 denotes an active layer, Number or Vector, (default: [1,..,1])\nx₀: position of vortex center, vector (default: [0, 0])\nα: initial angle of vortex, Number (default: 0)\nK₀, a₀: initial guesses for K and a, Arrays or nothings (default: nothing)\ntol: error tolerance passed to QuadGK and NLSolve functions, Number (default: 1e-6)\n\nNote: provide values of K₀ and a₀ for active layers ONLY.\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.CreateModonSQG","page":"List of Functions","title":"QGDipoles.CreateModonSQG","text":"Function: CreateModonSQG(grid, M, U=1, ℓ=1, R=[Inf, Inf], β=0, x₀=[0, 0], α=0; K₀=nothing, a₀=nothing, tol=1e-6)\n\nHigh level wrapper function for calculating ψ and b for the SQG model using given parameters\n\nArguments:\n\ngrid: grid structure containing x, y, and Krsq\nM: number of coefficient to solve for, Integer (default: 12)\n(U, ℓ): vortex speed and radius, Numbers (default: (1, 1))\nR: vector of [R, R'], Vector (default: [Inf, Inf])\nβ: beta-plane (y) PV gradient, Number (default: 0)\nx₀: position of vortex center, vector (default: [0, 0])\nα: initial angle of vortex, Number (default: 0)\nK₀, a₀: initial guesses for K and a, Arrays or nothings (default: nothing)\ntol: error tolerance passed to QuadGK and NLSolve functions, Number (default: 1e-6)\n\nNote: Here R is the baroclinic Rossby radius, R = NH/f, and R' = R₀²/R where R₀ is the barotropic Rossby radius, R₀ = √(gH)/f. For infinite depth, R' = g/(fN).\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.CreateLCD","page":"List of Functions","title":"QGDipoles.CreateLCD","text":"Function: CreateLCD(grid, U=1, ℓ=1, x₀=[0, 0], α=0)\n\nHigh level wrapper function for calculating ψ and q for the Lamb-Chaplygin dipole using given parameters\n\nArguments:\n\ngrid: grid structure containing x, y, and Krsq\n(U, ℓ): vortex speed and radius, Numbers (default: (1, 1))\nx₀: position of vortex center, vector (default: [0, 0])\nα: initial angle of vortex, Number (default: 0)\n\nNote: This function uses the analytic solution for the LCD to calculate ψ and q.\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.CreateLRD","page":"List of Functions","title":"QGDipoles.CreateLRD","text":"Function: CreateLRD(grid, U=1, ℓ=1, R=1, β=0, x₀=[0, 0], α=0)\n\nHigh level wrapper function for calculating ψ and q for the Larichev-Reznik dipole using given parameters\n\nArguments:\n\ngrid: grid structure containing x, y, and Krsq\n(U, ℓ): vortex speed and radius, Numbers (default: (1, 1))\n(R, β): Rossby radii and (y) PV gradient, Numbers, (default: (1, 0))\nx₀: position of vortex center, vector (default: [0, 0])\nα: initial angle of vortex, Number (default: 0)\n\nNote: This function uses the analytic solution for the LRD to calculate ψ and q.\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.Eval_ψ_SQG","page":"List of Functions","title":"QGDipoles.Eval_ψ_SQG","text":"Function: Eval_ψ_SQG(grid, ψ, z=[0], U=1, R=[Inf, Inf], β=0)\n\nEvaluates ψ at specified depths, z in [-R, 0], for the SQG problem\n\nArguments:\n\ngrid: grid structure containing x, y, and Krsq\nψ: surface streamfunction, calculated using Calc_ψb or CreateModonSQG\nz: vector of depths (default: [0])\nU: vortex speed, Number (default: 1)\nR: vector of [R, R'], Vector (default: [Inf, Inf])\nβ: beta-plane (y) PV gradient, Number (default: 0)\n\nNote: Here R is the baroclinic Rossby radius, R = NH/f, and R' = R₀²/R where R₀ is the barotropic Rossby radius, R₀ = √(gH)/f. For infinite depth, R' = g/(fN).\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.Eval_q_SQG","page":"List of Functions","title":"QGDipoles.Eval_q_SQG","text":"Function: Eval_q_SQG(grid, ψ, z=[0], U=1, R=[Inf, Inf], β=0)\n\nEvaluates q at specified depths, z in [-R, 0], for the SQG problem\n\nArguments:\n\ngrid: grid structure containing x, y, and Krsq\nψ: surface streamfunction, calculated using Calc_ψb or CreateModonSQG\nz: vector of depths (default: [0])\nU: vortex speed, Number (default: 1)\nR: vector of [R, R'], Vector (default: [Inf, Inf])\nβ: beta-plane (y) PV gradient, Number (default: 0)\n\nNote: Here R is the baroclinic Rossby radius, R = NH/f, and R' = R₀²/R where R₀ is the barotropic Rossby radius, R₀ = √(gH)/f. For infinite depth, R' = g/(fN).\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.Eval_b_SQG","page":"List of Functions","title":"QGDipoles.Eval_b_SQG","text":"Function: Eval_b_SQG(grid, ψ, z=[0], U=1, R=[Inf, Inf], β=0)\n\nEvaluates b at specified depths, z in [-R, 0], for the SQG problem\n\nArguments:\n\ngrid: grid structure containing x, y, and Krsq\nψ: surface streamfunction, calculated using Calc_ψb or CreateModonSQG\nz: vector of depths (default: [0])\nU: vortex speed, Number (default: 1)\nR: vector of [R, R'], Vector (default: [Inf, Inf])\nβ: beta-plane (y) PV gradient, Number (default: 0)\n\nNote: Here R is the baroclinic Rossby radius, R = NH/f, and R' = R₀²/R where R₀ is the barotropic Rossby radius, R₀ = √(gH)/f. For infinite depth, R' = g/(fN).\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.Eval_w_SQG","page":"List of Functions","title":"QGDipoles.Eval_w_SQG","text":"Function: Eval_w_SQG(grid, ψ, z=[0], U=1, R=[Inf, Inf], β=0)\n\nEvaluates N²w at specified depths, z in [-R, 0], for the SQG problem using N²w = -J[ψ + Uy, b]\n\nArguments:\n\ngrid: grid structure containing x, y, and Krsq\nψ: surface streamfunction, calculated using Calc_ψb or CreateModonSQG\nz: vector of depths (default: [0])\nU: vortex speed, Number (default: 1)\nR: vector of [R, R'], Vector (default: [Inf, Inf])\nβ: beta-plane (y) PV gradient, Number (default: 0)\n\nNote: Here R is the baroclinic Rossby radius, R = NH/f, and R' = R₀²/R where R₀ is the barotropic Rossby radius, R₀ = √(gH)/f. For infinite depth, R' = g/(fN).\n\nNote: this function is not accurate at the surface as ∇b is discontinuous there. Instead use w = -U∂η/∂x where η = fψ/g is the surface elevation, or w = 0 if R' = ∞.\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.Calc_∇","page":"List of Functions","title":"QGDipoles.Calc_∇","text":"Function: Calc_∇(f, grid)\n\nCalculate the gradient ∇f for a given field f\n\nArguments:\n\nf: function, Array\ngrid: grid structure containing kr and l\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.CartesianGrid","page":"List of Functions","title":"QGDipoles.CartesianGrid","text":"Function: CartesianGrid(grid)\n\nFormats the (x, y) ranges from grid as two-dimensional Arrays\n\nArguments:\n\ngrid: grid structure containing kr and l\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.PolarGrid","page":"List of Functions","title":"QGDipoles.PolarGrid","text":"Function: PolarGrid(x, y, x₀)\n\nCalculates the polar coordinates from (x, y) as two-dimensional Array centred on x₀\n\nArguments:\n\nx, y: 2D Arrays for x and y, created using CartesianGrid\nx₀: Vector\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.Calc_ζ","page":"List of Functions","title":"QGDipoles.Calc_ζ","text":"Function: Calc_ζ(ψ, grid)\n\nCalculate the vertical vorticity using ζ = ∂v/∂x - ∂u/∂y = ∇²ψ\n\nArguments:\n\nψ: streamfunction, Array\ngrid: grid structure containing Krsq\n\n\n\n\n\n","category":"function"},{"location":"Functions/#energetics.jl","page":"List of Functions","title":"energetics.jl","text":"","category":"section"},{"location":"Functions/","page":"List of Functions","title":"List of Functions","text":"EnergyLQG\nEnstrophyLQG\nEnergySQG\nAreaInteg2","category":"page"},{"location":"Functions/#QGDipoles.EnergyLQG","page":"List of Functions","title":"QGDipoles.EnergyLQG","text":"Function: EnergyLQG(grid, ψ, R, H=[1])\n\nCalculates the kinetic and potential energy for the LQG system\n\nArguments:\n\ngrid: grid structure containing Krsq\nψ: streamfunction in each layer, Array or CuArray\nR: Rossby radius in each layer, Number or Vector\nH: Thickness of each layer, Number or Vector\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.EnstrophyLQG","page":"List of Functions","title":"QGDipoles.EnstrophyLQG","text":"Function: EnstrophyLQG(grid, q, H=[1])\n\nCalculates the enstrophy for the LQG system\n\nArguments:\n\ngrid: grid structure containing Krsq\nq: potential vorticity anomaly in each layer, Array or CuArray\nH: Thickness of each layer, Number or Vector\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.EnergySQG","page":"List of Functions","title":"QGDipoles.EnergySQG","text":"Function: EnergySQG(grid, ψ, b, R′)\n\nCalculates the energies for the SQG system; the total domain integrated energy and the surface potential energy\n\nArguments:\n\ngrid: grid structure containing Krsq\nψ: surface streamfunction, Array or CuArray\nb: surface buoyancy, , Array or CuArray\nR′: reduced barotropic Rossby radius, Number (default: Inf)\n\nNote: the surface potential energy is sometimes referred to as the generalised enstrophy or the buoyancy variance.\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.AreaInteg2","page":"List of Functions","title":"QGDipoles.AreaInteg2","text":"Function: AreaInteg2(f, grid)\n\nCalculates the integral I = int_A f^2 mathrmdA where A is the 2D domain described by grid.\n\nArguments:\n\nf: input Array in real or Fourier space\ngrid: grid structure\n\nNote: f can be entered in real space or Fourier space, we use the rfft function to calculate the Fourier transform so array sizes can distinguish the two.\n\n\n\n\n\n","category":"function"},{"location":"Functions/#vortex_types.jl","page":"List of Functions","title":"vortex_types.jl","text":"","category":"section"},{"location":"Functions/","page":"List of Functions","title":"List of Functions","text":"LQGParams\nSQGParams\nLQGVortex\nSQGVortex\nDefLQGParams\nDefSQGParams\nDefLQGVortex\nDefSQGVortex","category":"page"},{"location":"Functions/#QGDipoles.LQGParams","page":"List of Functions","title":"QGDipoles.LQGParams","text":"Structure: LQGParams\n\nStores the parameters for an LQG dipolar vortex solution\n\nArguments:\n\nU: Vortex speed\nℓ: Vortex radius\nR: Rossby radius\nβ: background PV gradient\nActiveLayers: 1 => layer contains vortex region\nH: thickness of each layer\nx₀: Vortex position\nα: Direction of vortex propagation\nM: number of coefficients in Zernike expansion\ntol: maximum error in solution evaluation\nK₀: initial guess for eigenvalue\na₀: initial guess for coefficients\nUseAnalytic: use analytic solution (1-layer only)\nCalcVelocity: flag to determine if velocity is calculated\nCalcVorticity: flag to determine if vorticity is calculated\nCalcEnergy: flag to determine if energy is calculated\nCalcEnstrophy: flag to determine if enstrophy is calculated\n\n\n\n\n\n","category":"type"},{"location":"Functions/#QGDipoles.SQGParams","page":"List of Functions","title":"QGDipoles.SQGParams","text":"Structure: SQGParams\n\nStores the parameters for an SQG dipolar vortex solution\n\nArguments:\n\nU: Vortex speed\nℓ: Vortex radius\nR: Rossby radius\nβ: background PV gradient\nx₀: Vortex position\nα: Direction of vortex propagation\nM: number of coefficients in Zernike expansion\ntol: maximum error in solution evaluation\nK₀: initial guess for eigenvalue\na₀: initial guess for coefficients\nCalcVelocity: flag to determine if velocity is calculated\nCalcVorticity: flag to determine if vorticity is calculated\nCalcEnergy: flag to determine if energy is calculated\n\n\n\n\n\n","category":"type"},{"location":"Functions/#QGDipoles.LQGVortex","page":"List of Functions","title":"QGDipoles.LQGVortex","text":"Structure: LQGVortex\n\nStores fields and diagnostics for an LQG dipolar vortex solution\n\nArguments:\n\nparams: Vortex params\nψ: streamfunction\nq: potential vorticity anomaly\nK: eigenvalue\na: coefficient matrix\nu: x velocity\nv: y velocity\nζ: vertical vorticity\nKE: kinetic energy\nPE: potential energy\nEN: enstrophy \n\n\n\n\n\n","category":"type"},{"location":"Functions/#QGDipoles.SQGVortex","page":"List of Functions","title":"QGDipoles.SQGVortex","text":"Structure: SQGVortex\n\nStores fields and diagnostics for an SQG dipolar vortex solution\n\nArguments:\n\nparams: Vortex params\nψ: surface streamfunction\nb: surface buoyancy\nK: eigenvalue\na: coefficient matrix\nu: x velocity\nv: y velocity\nζ: vertical vorticity\nE: domain integrated energy\nSPE: surface potential energy\n\n\n\n\n\n","category":"type"},{"location":"Functions/#QGDipoles.DefLQGParams","page":"List of Functions","title":"QGDipoles.DefLQGParams","text":"Function: DefLQGParams\n\nDefines an LQGParams structure using the given inputs\n\nArguments:\n\nU: Vortex speed\nℓ: Vortex radius\nR: Rossby radius\nβ: background PV gradient\nActiveLayers: 1 => layer contains vortex region\nH: thickness of each layer\nx₀: Vortex position\nα: Direction of vortex propagation\nM: number of coefficients in Zernike expansion\ntol: maximum error in solution evaluation\nK₀: initial guess for eigenvalue\na₀: initial guess for coefficients\nUseAnalytic: use analytic solution (1-layer only)\nCalcVelocity: flag to determine if velocity is calculated\nCalcVorticity: flag to determine if vorticity is calculated\nCalcEnergy: flag to determine if energy is calculated\nCalcEnstrophy: flag to determine if enstrophy is calculated\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.DefSQGParams","page":"List of Functions","title":"QGDipoles.DefSQGParams","text":"Function: DefSQGParams\n\nDefines an SQGParams structure using the given inputs\n\nArguments:\n\nU: Vortex speed\nℓ: Vortex radius\nR: Rossby radius\nβ: background PV gradient\nx₀: Vortex position\nα: Direction of vortex propagation\nM: number of coefficients in Zernike expansion\ntol: maximum error in solution evaluation\nK₀: initial guess for eigenvalue\na₀: initial guess for coefficients\nCalcVelocity: flag to determine if velocity is calculated\nCalcVorticity: flag to determine if vorticity is calculated\nCalcEnergy: flag to determine if energy is calculated\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.DefLQGVortex","page":"List of Functions","title":"QGDipoles.DefLQGVortex","text":"Function: DefLQGVortex\n\nDefines an LQGVortex solution structure using the given inputs\n\nArguments:\n\ngrid: grid structure\nU: Vortex speed\nℓ: Vortex radius\nR: Rossby radius\nβ: background PV gradient\nActiveLayers: 1 => layer contains vortex region\nH: thickness of each layer\nx₀: Vortex position\nα: Direction of vortex propagation\nM: number of coefficients in Zernike expansion\ntol: maximum error in solution evaluation\nK₀: initial guess for eigenvalue\na₀: initial guess for coefficients\nUseAnalytic: use analytic solution (1-layer only)\nCalcVelocity: flag to determine if velocity is calculated\nCalcVorticity: flag to determine if vorticity is calculated\nCalcEnergy: flag to determine if energy is calculated\nCalcEnstrophy: flag to determine if enstrophy is calculated\n\n\n\n\n\nFunction: DefLQGVortex\n\nDefines an LQGVortex solution structure using the given inputs\n\nArguments:\n\ngrid: grid structure\nparams: vortex parameters, LQGParams structure\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.DefSQGVortex","page":"List of Functions","title":"QGDipoles.DefSQGVortex","text":"Function: DefSQGVortex\n\nDefines an SQGVortex solution structure using the given inputs\n\nArguments:\n\ngrid: grid structure\nU: Vortex speed\nℓ: Vortex radius\nR: Rossby radius\nβ: background PV gradient\nx₀: Vortex position\nα: Direction of vortex propagation\nM: number of coefficients in Zernike expansion\ntol: maximum error in solution evaluation\nK₀: initial guess for eigenvalue\na₀: initial guess for coefficients\nCalcVelocity: flag to determine if velocity is calculated\nCalcVorticity: flag to determine if vorticity is calculated\nCalcEnergy: flag to determine if energy is calculated\n\n\n\n\n\nFunction: DefSQGVortex\n\nDefines an SQGVortex solution structure using the given inputs\n\nArguments:\n\ngrid: grid structure\nparams: vortex parameters, LQGParams structure\n\n\n\n\n\n","category":"function"},{"location":"Functions/#monopoles.jl","page":"List of Functions","title":"monopoles.jl","text":"","category":"section"},{"location":"Functions/","page":"List of Functions","title":"List of Functions","text":"CreateRankine\nCreate1LMonopole\nInvertVorticity1LQG\nCreateLQGMonopole\nInvertVorticityLQG","category":"page"},{"location":"Functions/#QGDipoles.CreateRankine","page":"List of Functions","title":"QGDipoles.CreateRankine","text":"Function: CreateRankine(grid, ℓ=1, Γ=2π, x₀=[0, 0])\n\nCalculates the Rankine vortex for a 1 layer system. This vortex appears as a point vortex in the far field but consists of solid body rotation within the region r < ℓ.\n\nArguments:\n\ngrid: grid structure containing x, y, and Krsq\nℓ: vortex speed and radius, Numbers (default: 1)\nΓ: vortex circulation (default: 2π)\nx₀: position of vortex center, vector (default: [0, 0])\n\nNote: This function outputs (u, v) directly since the solution has discontinuous velocity at the vortex boundary, r = ℓ, so derivatives evaluated with Fourier transforms exhibit Gibbs phenomenon.\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.Create1LMonopole","page":"List of Functions","title":"QGDipoles.Create1LMonopole","text":"Function: Create1LMonopole(grid, ℓ=1, Γ=2π, R=Inf, x₀=[0, 0])\n\nCalculates a monopolar vortex satisfying a Long's model assumption q = F(ψ) where q = [∇²-1/R²]ψ. We take F(z) = -(K²+1/R²)(z-z₀) for r < ℓ and F(z) = 0 for r > ℓ and z₀ = ψ(r=ℓ). These solutions exist only on an f-plane (β = 0).\n\nArguments:\n\ngrid: grid structure containing x, y, and Krsq\nℓ: vortex speed and radius, Numbers (default: 1)\nΓ: vortex circulation (default: 2π)\nR: Rossby radius (default: Inf)\nx₀: position of vortex center, vector (default: [0, 0])\n\nNote: This vortex has a continuous vorticity distribution so calculating (u, v) from ψ with Fourier transforms will work. This function outputs (u, v) from the analytical expressions for consistency with CreateRankine.\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.InvertVorticity1LQG","page":"List of Functions","title":"QGDipoles.InvertVorticity1LQG","text":"Function: InvertVorticity1LQG(grid, q, R=Inf)\n\nThis function inverts the potential vorticity relation q = [∇²-1/R²]ψ for 1-layer QG\n\nArguments:\n\ngrid: grid structure containing x, y, and Krsq\nq: potential vorticity field, Array\nR: Rossby radius (default: Inf)\n\nNote: This function is designed to be used for creating periodic streamfunctions using the vorticity fields generated by CreateMonopole. It does not support multi-layer QG and is only valid on an f-plane (β = 0).\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.CreateLQGMonopole","page":"List of Functions","title":"QGDipoles.CreateLQGMonopole","text":"Function: CreateLQGMonopole(grid, ℓ=1, E=1, R=Inf, x₀=[0, 0])\n\nCalculates a monopolar vortex in the LQG model using a numerical approach. We assume that qⱼ + βⱼ = Fⱼ(ψⱼ + Uy) and write Fⱼ(z) = -Kⱼ² z + Eⱼ. Expanding the expression gives qⱼ + βⱼ = -Kⱼ²(ψⱼ + Uy) + Eⱼ which by linearity can be split into a dipole equation qⱼ + βⱼ = -Kⱼ²(ψⱼ + Uy) and a monopole equation qⱼ = Eⱼ. Outside the vortex, we take qⱼ = 0.\n\nArguments:\n\ngrid: grid structure containing x, y, and Krsq\nℓ: vortex speed and radius, Numbers (default: 1)\nE: vector of Eⱼ values, Number or Vector (default: [1, ... , 1])\nR: Rossby radius (default: Inf)\nx₀: position of vortex center, vector (default: [0, 0])\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.InvertVorticityLQG","page":"List of Functions","title":"QGDipoles.InvertVorticityLQG","text":"Function: InvertVorticityLQG(grid, q, R=Inf)\n\nThis function inverts the potential vorticity relation q = ΔN ψ for the LQG model\n\nArguments:\n\ngrid: grid structure containing x, y, and Krsq\nq: potential vorticity field, Array\nR: Rossby radius, Number or Vector (default: Inf)\n\n\n\n\n\n","category":"function"},{"location":"Functions/#Base","page":"List of Functions","title":"Base","text":"","category":"section"},{"location":"Functions/","page":"List of Functions","title":"List of Functions","text":"Base.summary\nBase.show","category":"page"},{"location":"Functions/#Base.summary","page":"List of Functions","title":"Base.summary","text":"Base.summary function for custom type GridStruct\n\n\n\n\n\nBase.summary function for custom type LQGParams\n\n\n\n\n\nBase.summary function for custom type SQGParams\n\n\n\n\n\nBase.summary function for custom type LQGVortex\n\n\n\n\n\nBase.summary function for custom type SQGVortex\n\n\n\n\n\n","category":"function"},{"location":"Functions/#Base.show","page":"List of Functions","title":"Base.show","text":"Base.show function for custom type GridStruct\n\n\n\n\n\nBase.show function for custom type LQGParams\n\n\n\n\n\nBase.show function for custom type SQGParams\n\n\n\n\n\nBase.show function for custom type LQGVortex\n\n\n\n\n\nBase.show function for custom type SQGVortex\n\n\n\n\n\n","category":"function"},{"location":"#QGDipoles.jl","page":"Home","title":"QGDipoles.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation and examples for QGDipoles.jl by Matthew N. Crowe.","category":"page"},{"location":"#About","page":"Home","title":"About","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This Julia package provides functions for evaluating dipolar vortex solutions in the surface quasi-geostrophic (SQG) and multi-layer quasi-geostrophic (LQG) models. It is intended for use by those researching vortex dynamics in strongly rotating flows, in particular for researchers in physical oceanography and atmospheric dynamics. This package is based on the semi-analytic theory of dipolar vortices derived in Johnson & Crowe 2023[1] and Crowe & Johnson 2023[2] for SQG solutions and Crowe & Johnson 2024[3] for LQG solutions. The method used a basis of orthogonal polynomials (Zernike radial functions) to convert a steady PDE into a linear algebra system which is solved using standard methods. This code consists of an updated version of the MATLAB code released as supplementary material with Crowe & Johnson 2024[3] and incorporates (unreleased) functions for the SQG problem. For those interested in the original (LQG only) implementation, it can be found here.","category":"page"},{"location":"#Method-Summary","page":"Home","title":"Method Summary","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The full method is outlined in Johnson & Crowe 2023[1], Crowe & Johnson 2023[2] and 2024[3]. A summary is presented here such that the notation and examples presented later make some sense. We consider a dipolar vortex of radius ell, moving with speed U. This vortex consists of an isolated region of high vorticity with a closed streamline at x^2 + y^2 = ell^2 (in a frame co-moving with the vortex), hence fluid does not escape during propagation. Within the vortex core, x^2 + y^2  ell^2, are two counter rotating regions, corresponding to a dipole. The streamfunction describing the flow is denoted by psi and potential vorticity (PV) anomaly by q. Velocities may be derived as (u v) = (-partial_ypsi partial_xpsi). The streamfunction, psi, and PV anomaly, q, are related through PV inversion. In the case of multiple layers, psi and q are vector valued functions of length equal to the number of layers, N.","category":"page"},{"location":"#Layered-Quasi-Geostrophic-(LQG)-Solutions","page":"Home","title":"Layered Quasi-Geostrophic (LQG) Solutions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In the LQG model, steady, propagating, dipolar vortices satisfy the relation","category":"page"},{"location":"","page":"Home","title":"Home","text":"q_i + beta_i y = F_i(psi_i + Uy)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where beta_i denotes the background PV gradient, i in 1dotsN is the layer index and F_i is an arbitrary (piecewise continuous) function. To proceed, we assume that F_i(z) = (beta_iU) z for x^2 + y^2  ell^2 (outside the vortex) and F_i(z) = -(K_i^2ell^2) z for x^2 + y^2  ell^2 (inside the vortex). Using a Hankel transform and expansion in term of Zernike radial functions, the problem may be reduced to the linear algebra system","category":"page"},{"location":"","page":"Home","title":"Home","text":"left textbfA -  sum _n = 1^N K_n^2textbfB_n right textbfa = textbfc_0 + sum _n = 1^N K_n^2 textbfc_n","category":"page"},{"location":"","page":"Home","title":"Home","text":"where textbfA and textbfB_n are matrices, textbfa is a vector containing the coefficients in the polynomial expansion, textbfc_j are vectors and the K_n are defined in F_i above and appear as unknown eigenvalues in the linear problem. In order to solve the system, N additional conditions are required. These are textbfd_n cdot textbfa = 0 for n in 1 dots N where the textbfd_n are vectors. These conditions correspond to the requirement that the streamfunction and vorticity are continuous in each layer. In principal, we have an infinite number of coefficients in textbfa. However, since we know that these coefficients must decay with increasing index (since psi is continuous), we can truncate the expansion after M terms. The resulting linear system is of size MN times MN.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Solving this system determines the expansion coefficients and eigenvalues and hence allows psi and q to be evaluated on any given spatial grid. In the one-layer case the problem reduces to known analytical solutions, such as the Lamb-Chaplygin dipole[4] and the Larichev-Reznik dipole[5].","category":"page"},{"location":"#Surface-Quasi-Geostrophic-(SQG)-Solutions","page":"Home","title":"Surface Quasi-Geostrophic (SQG) Solutions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In the SQG model, steady, propagating, dipolar vortices satisfy the relation","category":"page"},{"location":"","page":"Home","title":"Home","text":"leftpartial_z + frac1Rright psi = F(psi + Uy)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where","category":"page"},{"location":"","page":"Home","title":"Home","text":"partial_z = sqrt-nabla^2 + betaU hspace5pt tanh leftR sqrt-nabla^2 + betaU right","category":"page"},{"location":"","page":"Home","title":"Home","text":"is a Dirichlet-Neumann operator linking the surface streamfunction, psi, and the surface buoyancy, b = partial_z psi. Here, (R R) describes the baroclinic and barotropic Rossby radii and beta is the background vorticity gradient. We assume that F(z) = 0 for x^2 + y^2  ell^2 (outside the vortex) and F_i(z) = -(Kell) z for x^2 + y^2  ell^2. Using a Hankel transform and expansion in term of Zernike radial functions, the problem may be reduced to the linear algebra system","category":"page"},{"location":"","page":"Home","title":"Home","text":"left textbfA -  KtextbfB right textbfa = textbfc_0 + K textbfc_1","category":"page"},{"location":"","page":"Home","title":"Home","text":"where textbfA and textbfB are matrices, textbfc_i are vectors, textbfa is a vector of coefficients and K is an eigenvalue related to F. An additional condition is required to solve this system for a unique set of K. This condition is taken to be continuity across the vortex boundary and corresponds to textbfd cdot textbfa = 0 for some vector textbfd. In principal, we have an infinite number of coefficients in textbfa. However, since we know that these coefficients must decay with increasing index (since psi is continuous), we can truncate the expansion after M terms. The resulting linear system is of size M times M.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Solving this linear system allows the surface streamfunction, psi, and surface bouyancy, b, to be calculated.","category":"page"},{"location":"#Solving-the-Linear-System","page":"Home","title":"Solving the Linear System","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Consider the multi-parameter, inhomogeneous eigenvalue problem","category":"page"},{"location":"","page":"Home","title":"Home","text":"left textbfA -  sum _n = 1^N K_n^mtextbfB_n right textbfa = textbfc_0 + sum _n = 1^N K_n^m textbfc_n quad textrmst quad textbfd_n cdot textbfa = 0 quad textrmfor quad n in 1 dots N","category":"page"},{"location":"","page":"Home","title":"Home","text":"which describes both the SQG (m N = 1) and LQG (m = 2) systems. For N = 1, this system may be converted into a quadratic eigenvalue problem and solved by standard techniques. For N  1, existing techniques scale poorly with matrix size so we take an alternative approach and find (K textbfa) using a root finding method, where the orthogonality conditions (textbfd_n cdot textbfa = 0) are used to reduce the dimension of the space. These two approaches are described in the Appendix of Crowe & Johnson 2024[3].","category":"page"},{"location":"#Recovering-the-Vortex-Solution","page":"Home","title":"Recovering the Vortex Solution","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Once the coefficients are determined, they are multiplied by the basis polynomials and summed on a specified numerical grid to give an intermediate field, textbfF. The streamfunction, psi, potential vorticity anomaly, q (LQG), and surface buoyancy, b (SQG), are related to textbfF by differential operators and may be calculated using discrete Fourier transforms. Note that the streamfunction may decay slowly in the far-field for certain parameters so a sufficiently large domain is required to avoid Gibbs phenemenon near the domain edges.","category":"page"},{"location":"#Integration-with-GeophysicalFlows.jl","page":"Home","title":"Integration with GeophysicalFlows.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is designed to work with the TwoDGrid structure from FourierFlows.jl and GeophysicalFlows.jl[6]. As such, these functions may be used to define initial conditions for layered and surface quasi-geostrophic simulations which may run on either CPUs or GPUs. However, FourierFlows.jl and GeophysicalFlows.jl are NOT required to use this package as an alternative grid structure is available (created using CreateGrid), which uses the same field names as the eqivalent FourierFlows.jl function.","category":"page"},{"location":"#Equations-and-Parameters","page":"Home","title":"Equations and Parameters","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This section contains a summary of the LQG and SQG systems of equations and tables which summarise all parameters used in functions and structures of QGDipoles.jl.","category":"page"},{"location":"#The-LQG-System","page":"Home","title":"The LQG System","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The layered QG equations are","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n(partial_t - U partial_x) q_i + J(psi_iq_i) + beta_i partial_x psi_i = 0 quad i in 12dots N\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"where the potential vorticity in each layer, q_i, is given in terms of the streamfunction in each layer, psi_i, by","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nbeginalign*\nq_1 =  nabla^2 psi_1 + R_1^-2 (psi_2 - psi_1)\nq_i =  nabla^2 psi_i + R_i^-2 (psi_i-1-2psi_i+psi_i+1) quad i in 2dots N-1\nq_N =  nabla^2 psi_N  + R_N^-2 (psi_N-1-psi_N)\nendalign*\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"and R_i = sqrtgH_if is the Rossby radius of deformation in each layer. The full list of parameters for the LQG system is given in the table below.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Parameter Description Definition\nU vortex speed -\nell vortex radius -\nbeta background (y) vorticity gradient in each layer -\nR Rossby radius in each layer R_i = sqrt gH_i  f\nlambda ratio of radius to R in each layer lambda_i = ell  R_i\nmu rescaled vorticity gradient mu_i = beta_i ell^2  U\nalpha angle of vortex propagation -\nx_0 position of vortex center -\nN number of layers -\nM number of terms in polynomial expansion -\ng buoyancy difference between each layer -\nf Coriolis parameters -\nH layer depth in each layer -","category":"page"},{"location":"#The-SQG-System","page":"Home","title":"The SQG System","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The 3D QG equations are","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n(partial_t - U partial_x) q + J(psiq) + beta partial_x psi = 0 quad textrmfor quad z in -R 0\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"where","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nq = leftfracpartial^2partial x^2 + fracpartial^2partial y^2 + fracpartial^2partial z^2right psi quad textrmfor quad z in -R 0\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"and R = NHf is the Baroclinic Rossby radius. Note that we have rescaled z by Nf so q and psi are related by the 3D Laplacian operator. The top boundary condition is taken to be","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n(partial_t - U partial_x) b + N^2 eta + J(psi b + N^2 eta) = 0 quad textrmon quad z  = 0\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"and we assume that b = 0 on the bottom surface, z = -R. Here, b = N partialpsipartial z is the buoyancy and eta = fpsig is the surface elevation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The SQG system is typically derived by assuming that q = 0 in the interior. We instead take q = (betaU)psi which satisfies the steady evolution equation for q given above and reduces to the usual result for beta = 0. Since b(z = 0) can be determined from psi(z = 0) using the Dirichlet-Neumann operator given above, this system reduces to a 2D system for the modified surface buoyancy, b + N^2 eta, only.","category":"page"},{"location":"","page":"Home","title":"Home","text":"QGDipoles.jl solves for steady, dipolar solutions to this surface equation and hence calculates only the surface values of b and psi using Calc_ψb or CreateModonSQG. If a 3D solution is required, the functions Eval_ψ_SQG, Eval_q_SQG and Eval_b_SQG can be used to calculate ψ, q and b at specified depths. Alternatively, a layered model with a large number of layers can be used to model the continuous system. The full list of parameters for the SQG system is given in the table below.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note: this package returns bN rather than b. When working with dimensional variables, this factor of 1N should be included manually.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Parameter Description Definition\nU vortex speed -\nell vortex radius -\nbeta background (y) vorticity gradient in each layer -\nR baroclinic Rossby radius R = NH  f\nR reduced barotropic Rossby radius R = R_0^2  R\nlambda ratio of radius to R lambda = ell  R\nmu rescaled vorticity gradient mu = beta ell^2  U\nalpha angle of vortex propagation -\nx_0 position of vortex center -\nM number of terms in polynomial expansion -\nN buoyancy frequency -\nR_0 barotropic Rossby radius R_0 = sqrt gH  f\ng gravitational acceleration -\nf Coriolis parameters -\nH layer depth -","category":"page"},{"location":"","page":"Home","title":"Home","text":"[1]: Johnson, E. R., and M. N. Crowe, 2023, Oceanic dipoles in a surface quasigeostrophic model, J. Fluid Mech., 958, R2.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[2]: Crowe, M. N., and E. R. Johnson, 2023, The evolution of surface quasi-geostrophic modons on sloping topography, J. Fluid. Mech., 970, A10.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[3]: Crowe, M. N., and E. R. Johnson, 2024, Modon solutions in an N-layer quasi-geostrophic model, J. Fluid. Mech., 994, R1.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[4]: Lamb, H., 1932, Hydrodynamics. Cambridge University Press.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[5]: Larichev, V.D. & Reznik, G.M., 1976, Two-dimensional solitary Rossby waves, Dokl. Akad. Nauk SSSR, 12–13.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[6]: Constantinou et al., 2021, GeophysicalFlows.jl: Solvers for geophysical fluid dynamics problems in periodic domains on CPUs & GPUs, JOSS, 6(60), 3053.","category":"page"},{"location":"Installation/#Installation-Instructions","page":"Installation","title":"Installation Instructions","text":"","category":"section"},{"location":"Installation/","page":"Installation","title":"Installation","text":"Installing QGDipoles.jl is fairly straightforward and can be done using the Julia package manager. Note that QGDipoles is not (currently) listed as a Julia package so cannot be installed using ] add QGDipoles.","category":"page"},{"location":"Installation/#Installing","page":"Installation","title":"Installing","text":"","category":"section"},{"location":"Installation/","page":"Installation","title":"Installation","text":"To install use the Julia package manager:","category":"page"},{"location":"Installation/","page":"Installation","title":"Installation","text":"julia> ]\n(v1.10) pgk> add https://github.com/mncrowe/QGDipoles.jl.git\n(v1.10) pgk> instantiate","category":"page"},{"location":"Installation/","page":"Installation","title":"Installation","text":"This package is not compatible with versions of Julia earlier than 1.10 due to the eachslice function.","category":"page"},{"location":"Installation/#Dependencies","page":"Installation","title":"Dependencies","text":"","category":"section"},{"location":"Installation/","page":"Installation","title":"Installation","text":"This package requires the following dependencies:","category":"page"},{"location":"Installation/","page":"Installation","title":"Installation","text":"FFTW (v1.8.0)\nJacobi (v0.7.0)\nLinearAlgebra\nNLsolve (v4.5.1)\nQuadGK (v2.9.4)\nSpecialFunctions (v2.4.0)\nCUDA (v5.4.3)","category":"page"},{"location":"Installation/","page":"Installation","title":"Installation","text":"The specified versions are confirmed to work and earlier versions may also work. These packages will be automatically installed with QGDipoles.jl and do not need to be added seperately.","category":"page"}]
}
