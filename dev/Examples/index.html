<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · QGDipoles.jl</title><meta name="title" content="Examples · QGDipoles.jl"/><meta property="og:title" content="Examples · QGDipoles.jl"/><meta property="twitter:title" content="Examples · QGDipoles.jl"/><meta name="description" content="Documentation for QGDipoles.jl."/><meta property="og:description" content="Documentation for QGDipoles.jl."/><meta property="twitter:description" content="Documentation for QGDipoles.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="QGDipoles.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">QGDipoles.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Examples</a><ul class="internal"><li><a class="tocitem" href="#Example-1:-1-layer-QG"><span>Example 1: 1-layer QG</span></a></li><li><a class="tocitem" href="#Example-2:-multi-layer-QG"><span>Example 2: multi-layer QG</span></a></li><li><a class="tocitem" href="#Example-3:-SQG"><span>Example 3: SQG</span></a></li><li><a class="tocitem" href="#Example-4:-Wrappers"><span>Example 4: Wrappers</span></a></li><li><a class="tocitem" href="#Example-5:-A-GeophysicalFlows.jl-simulation"><span>Example 5: A GeophysicalFlows.jl simulation</span></a></li></ul></li><li><a class="tocitem" href="../Functions/">List of Functions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Examples</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mncrowe/QGDipoles.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mncrowe/QGDipoles.jl/blob/main/docs/src/Examples.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h1><p>Here we present some examples which demonstrate how to use this package. Further examples are available in the <code>examples/</code> directory <a href="https://github.com/mncrowe/QGDipoles.jl/tree/main/examples">here</a>.</p><h2 id="Example-1:-1-layer-QG"><a class="docs-heading-anchor" href="#Example-1:-1-layer-QG">Example 1: 1-layer QG</a><a id="Example-1:-1-layer-QG-1"></a><a class="docs-heading-anchor-permalink" href="#Example-1:-1-layer-QG" title="Permalink"></a></h2><p>Let&#39;s calculate and plot the Larichev-Reznik dipole (LRD). This diople exists on the <span>$\beta$</span>-plane in the equivalent barotropic model so we take <span>$\beta = R = 1$</span> and consider a 1-layer solution (<span>$N = 1$</span>). We&#39;ll also assume unit radius and velocity, <span>$\ell = U = 1$</span>. Let&#39;s start by loading the package and defining some parameters.</p><pre><code class="language-julia hljs">using QGDipoles

# Set problem parameters

U, ℓ = 1, 1	# vortex speed and radius
R = 1		# Rossby radius in each layer
β = 1		# background PV gradient in each layer

M = 8		# number of coefficients in Zernike expansion
tol = 1e-8	# maximum error in solution evaluation

# Set grid parameters

Nx, Ny = 512, 512
Lx, Ly = 10, 10</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(10, 10)</code></pre><p>We&#39;ve taken <span>$M = 8$</span> as this is generally a sufficient number of terms to get a relative error <span>$&lt; 10^{-6}$</span> in the final result. The tolerance, <code>tol</code>, is used in calculating the terms in the linear system and a value of <code>tol=10^{-8}</code> corresponds to approximately the same error as our chosen <span>$M$</span> value. We&#39;re also going to build a grid with <span>$512$</span> points in each direction and have taken the grid size to be <span>$10$</span> in each direction, which is sufficient to capture the far-field decay of the vortex. We can now build the linear system and solve for the coefficients as follows:</p><pre><code class="language-julia hljs"># Build and solve linear system for coefficients

λ = ℓ / R
μ = β * ℓ^2/U

A, B, c, d = BuildLinSys(M, λ, μ; tol)
K, a = SolveInhomEVP(A, B, c, d; K₀ = 4, tol)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([4.107870846981622;;], [-16.10786496734573; -20.993537516441386; … ; -3.5900817204483416e-5; -6.999086067914019e-7;;])</code></pre><p>The intermediate parameters, <span>$\lambda$</span> and <span>$\mu$</span>, describe the rescaled vortex radius and PV gradient. Finally, we can define a grid and evaluate our streamfunction, PV and velocities using:</p><pre><code class="language-julia hljs"># Create grid and calculate streamfunctions and vorticities

grid = CreateGrid(Nx, Ny, Lx, Ly)
ψ, q = Calc_ψq(a, U, ℓ, R, β, grid)
u, v = Calc_uv(ψ, grid)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([-0.00016005653105468417 -0.00016006984562186256 … -0.00016010967557845762 -0.00016006984562336526; -0.00016010432687723437 -0.0001601175977473052 … -0.00016015750785036004 -0.00016011759774867303; … ; -0.00016024762694954927 -0.00016026097797418304 … -0.00016030091728704498 -0.0001602609779759354; -0.00016010432687692532 -0.00016011759774753616 … -0.00016015750784980333 -0.00016011759774917003;;;], [3.0541516783516864e-17 -1.4135141931521002e-17 … 1.264901520458789e-16 5.1232829201968634e-17; 3.0839440799202306e-17 9.55479481800323e-8 … -1.9113234880090024e-7 -9.554794814597258e-8; … ; 2.944672770370145e-17 -1.9113234853381095e-7 … 3.8233761929677653e-7 1.91132348573951e-7; 3.00834900866109e-17 -9.554794820940947e-8 … 1.9113234905748483e-7 9.554794824583527e-8;;;])</code></pre><p>We can plot our solution using Plots.jl:</p><pre><code class="language-julia hljs">using Plots

heatmap(grid.x, grid.y, transpose(ψ[:,:,1]);
    colormap = :balance,
    aspect_ratio=1,
    xlims = (-Lx/2, Lx/2),
    ylims = (-Ly/2, Ly/2))</code></pre><img src="3238aa8d.svg" alt="Example block output"/><p>Note that we transpose <span>$\psi$</span> when plotting as <span>$x$</span> corresonds to the first dimension of <span>$\psi$</span>.</p><h2 id="Example-2:-multi-layer-QG"><a class="docs-heading-anchor" href="#Example-2:-multi-layer-QG">Example 2: multi-layer QG</a><a id="Example-2:-multi-layer-QG-1"></a><a class="docs-heading-anchor-permalink" href="#Example-2:-multi-layer-QG" title="Permalink"></a></h2><p>This example considers a 3-layer solution and introduces the concept of active and passive layers. We define an active layer to be a layer with a closed streamline at <span>$x^2 + y^2 = \ell^2$</span> whereas a passive layer has no closed streamlines. Therefore, fluid within the vortex in an active layer remains trapped in the vortex. Conversely, fluid in the passive layer is not trapped in a vortex core but can still be affected through the change in layer thickness associated with the streamfunction in neighbouring layers. Passive layers have <span>$F_i(z) = (\beta_i/U) z$</span> everywhere and hence have no eigenvalue, <span>$K_i$</span>, to solve for. Further, the coefficients within a passive layer are zero though the solution may still be non-zero due to the coefficients in neighbouring layers. Therefore, the corresponding linear system can be simplified by removing rows and columns corresponding to passive layers and solving the reduced system for the active layers only.</p><p>We&#39;ll start by defining some parameters:</p><pre><code class="language-julia hljs">using QGDipoles

# Set problem parameters

U, ℓ = 1, 1			# vortex speed and radius
R = [1, 1, 1]			# Rossby radius in each layer
β = [0, 0, 1]			# background PV gradient in each layer
ActiveLayers = [0, 1, 0]	# 1 =&gt; layer contains vortex region
x₀ = [5, 5]			# location of vortex center

M = 8				# number of coefficients in Zernike expansion
tol = 1e-8			# maximum error in solution evaluation

# Set grid parameters

Nx, Ny = 512, 512
Lx, Ly = [0, 10], [0, 10]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([0, 10], [0, 10])</code></pre><p>We&#39;ve assumed that only the middle layer is active. Therefore our solution will describe a mid-depth propagating structure. We&#39;ve also taken a background PV gradient in the lower layer only, to represent, say, a topographic slope. Finally, we&#39;ve taken our vortex to be centred at <span>$[5, 5]$</span> and taken <span>$x$</span> and <span>$y$</span> to run from <span>$0$</span> to <span>$10$</span>.</p><p>We start by building the full linear system:</p><pre><code class="language-julia hljs"># Build and solve linear system for coefficients

λ = ℓ ./ R
μ = β * ℓ^2/U

A, B, c, d = BuildLinSys(M, λ, μ; tol)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([0.24999999999999994 -5.764034005137029e-19 … 2.638620131393737e-22 7.805357408528992e-25; -6.454017486614197e-19 0.25 … 4.6384582982829554e-18 -4.6360326179970445e-24; … ; -4.578037095002218e-24 3.771096560294552e-18 … 0.031249999999999983 -4.813887479807181e-22; -1.8942563959165525e-16 4.370784976173563e-16 … -1.7993455057989642e-7 0.03118908717413678], [0.03159622386807064 0.006134960371591959 … -2.46211467431665e-16 1.894256395416378e-16; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0;;; 0.0 0.0 … 0.0 0.0; 0.006134960371591959 0.02695620863355798 … 1.0879936483664895e-12 -4.3563709778623497e-16; … ; -2.46211464019545e-16 1.0879936483664895e-12 … 6.091343008457629e-5 1.7993455057989168e-7; 0.0 0.0 … 0.0 0.0;;; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 1.8942563956729155e-16 -4.356370976828374e-16 … 1.7993455057989168e-7 6.091282587144038e-5], [0.0 0.25 0.0 0.0; 0.0 0.0 0.25 0.0; … ; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0], [1.0 0.0 0.0; 0.0 1.0 0.0; … ; 0.0 -1.0 0.0; 0.0 0.0 -1.0])</code></pre><p>Next we remove the passive layers:</p><pre><code class="language-julia hljs">A, B, c, d = ApplyPassiveLayers(A, B, c, d, ActiveLayers)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([0.25 3.800636834330046e-18 … -2.6350268546795224e-18 4.6384582982829554e-18; 1.8490729238561376e-18 0.12499999999999997 … 2.3011767594531204e-18 -3.648012085146661e-18; … ; -2.9060773978008985e-18 1.8674958904589187e-18 … 0.03571428571428572 5.3371546006493464e-18; 3.771096560294552e-18 -3.105910998903909e-18 … 6.963457859377603e-18 0.031249999999999983], [0.02695620863355798 0.004074160402632181 … -1.560380491224478e-13 1.0879936483664895e-12; 0.004074160402632181 0.003757870266000154 … 1.6683787915090247e-12 -1.1529662041822013e-12; … ; -1.56038045734316e-13 1.6683787915090247e-12 … 9.086908096833135e-5 3.687003050357272e-5; 1.0879936483664895e-12 -1.1529662041822142e-12 … 3.687003050357272e-5 6.091343008457629e-5;;;], [0.0 0.25; 0.0 0.0; … ; 0.0 0.0; 0.0 0.0], [1.0; -1.0; … ; 1.0; -1.0;;])</code></pre><p>We can now solve the reduced system and put the passive layers, which have <span>$(K, \textbf{a}) = (0, \textbf{0})$</span>, back in to ensure the sizes of <span>$K$</span> and <span>$\textbf{a}$</span> match the number of layers:</p><pre><code class="language-julia hljs">K, a = SolveInhomEVP(A, B, c, d; K₀ = 4, tol)
K, a = IncludePassiveLayers(K, a, ActiveLayers)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([0.0 4.183466902989521 0.0], [0.0 -13.937654353076338 0.0; 0.0 -18.077140544815745 0.0; … ; 0.0 -2.827956672128478e-5 0.0; 0.0 -5.424998191659326e-7 0.0])</code></pre><p>Finally, we can calculate our solution:</p><pre><code class="language-julia hljs"># Create grid and calculate streamfunctions and vorticities

grid = CreateGrid(Nx, Ny, Lx, Ly)
ψ, q = Calc_ψq(a, U, ℓ, R, β, grid, x₀)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([2.0529757757961711e-19 0.00017776752022326302 … -0.00035551841666216634 -0.00017776752022325858; 1.593695690204169e-19 0.00017778215258115206 … -0.00035554768182555695 -0.00017778215258114772; … ; 2.9572025181808367e-19 0.0001778260501025602 … -0.00035563547821207474 -0.00017782605010255575; 2.5075143535395414e-19 0.00017778215258115217 … -0.00035554768182555685 -0.00017778215258114767;;; 7.058151541338122e-18 0.00014462978143267363 … -0.00028924648717310346 -0.0001446297814326779; 6.736195347196103e-18 0.00014464206627977122 … -0.0002892710574175871 -0.00014464206627977556; … ; 7.680545216057757e-18 0.00014467892137147 … -0.00028934476925260527 -0.00014467892137147445; 7.373025323659779e-18 0.0001446420662797709 … -0.0002892710574175857 -0.00014464206627977534;;; 3.7049978919876435e-19 8.136101237287858e-5 … -0.00016271482284122837 -8.136101237287978e-5; 2.711245000059396e-19 8.136806412559916e-5 … -0.000162728926693479 -8.13680641256003e-5; … ; 5.679544601424167e-19 8.138921973063945e-5 … -0.00016277123894449264 -8.138921973064067e-5; 4.694747818723632e-19 8.136806412559902e-5 … -0.00016272892669347877 -8.136806412560021e-5], [-6.474867318705745e-35 1.5168184010089786e-19 … -2.9698372882737994e-19 -1.5168184010089998e-19; 1.6490041346372988e-19 3.1579190584176895e-19 … -1.312247727481269e-19 1.3901409397226945e-20; … ; -3.298764349087806e-19 -1.8072589358862584e-19 … -6.219274610749831e-19 -4.787898642726499e-19; -1.6490041346372914e-19 -1.3901409397229256e-20 … -4.604255412465014e-19 -3.1579190584177088e-19;;; -2.9460906202723842e-19 -4.611432653309654e-19 … -1.8674204515870538e-17 -2.4087468335553134e-16; 1.1536774861176794e-18 1.690280335771215e-17 … -1.1835716250113343e-18 -2.5391599898459833e-16; … ; -3.477759044231898e-18 -2.9085101626032813e-17 … -5.815609688056497e-17 -2.1455757322274235e-16; -1.742895610172251e-18 -1.6516940536736483e-17 … -3.7760940496484574e-17 -2.274455737474303e-16;;; 3.704997891987628e-19 8.136101237287593e-5 … -0.0001627148228412249 -8.136101237287912e-5; 4.907061158446085e-19 8.13680641255965e-5 … -0.00016272892669347527 -8.136806412559948e-5; … ; 1.2970122680499756e-19 8.138921973063679e-5 … -0.0001627712389444895 -8.138921973064048e-5; 2.498931660336922e-19 8.136806412559634e-5 … -0.00016272892669347538 -8.136806412559983e-5])</code></pre><h2 id="Example-3:-SQG"><a class="docs-heading-anchor" href="#Example-3:-SQG">Example 3: SQG</a><a id="Example-3:-SQG-1"></a><a class="docs-heading-anchor-permalink" href="#Example-3:-SQG" title="Permalink"></a></h2><p>This example covers the SQG vortex and introduces grids on a GPU. We&#39;ll start by defining some parameters. There are a few changes here compared to the LQG setup. Firstly, we&#39;ll need to set the flag <code>sqg</code> to <code>true</code> as the linear system is different in the SQG case and the functions assume LQG by default. Also, despite the SQG problem having only 1-layer, we enter <code>R</code> as a 2 element vector since we need both the (reduced) barotropic and baroclinic Rossby radii, <span>$R$</span> and <span>$R&#39;$</span>. We&#39;ll take these as <span>$\infty$</span> using <code>Int</code> and note that these functions accept infinite Rossby radii in both the SQG and LQG cases. However, <span>$R = 0$</span> is not valid since the QG assumptions break down in this limit. Note that we take <span>$M = 20$</span> here and in general we&#39;ll need more coefficients for the SQG problem compared to the LQG problem as they decay slower with coefficient number. This is compensated by the fact that the SQG system is faster to calculate than the LQG system.</p><pre><code class="language-julia hljs">using QGDipoles

# Set problem parameters

U, ℓ = 1, 1     	# vortex speed and radius
R = [Inf, Inf]		# Baroclinic and Barotropic Rossby radii
β = 0		    	# background PV gradient in the interior

M = 20		    	# number of coefficients in Zernike expansion
tol = 1e-6	    	# maximum error in solution evaluation
cuda = false		# use CuArrays for grid
method = 0	    	# 0; eigensolve/nlsolve, 1; nlsolve
sqg = true	    	# functions use SQG functionality

# Set grid parameters

Nx, Ny = 512, 512
Lx, Ly = 10, 10</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(10, 10)</code></pre><p>We have introduced a couple of new variables here. Firstly, <code>cuda</code> is a flag that is passed to the grid object and when set to <code>true</code> will create the grid on an available GPU. Secondly, <code>method</code> is passed to the linear system solver, <code>SolveInhomEVP</code>, and determines if root-finding is used as the default method (<code>method = 1</code>) or if the problem is solved by eigenvalue methods for the 1-layer LQG and SQG problems (<code>method = 0</code>). In general, <code>method = 0</code> should be used, but if you have a good initial guess for <span>$K$</span> and <span>$\textbf{a}$</span>, it may be faster to use <code>method = 1</code>.</p><p>Next we can build the linear system:</p><pre><code class="language-julia hljs"># Build and solve linear system for coefficients

λ = ℓ ./ R
μ = β * ℓ^2/U

A, B, c, d = BuildLinSys(M, λ, μ; tol, sqg)
K, a = SolveInhomEVP(A, B, c, d; K₀ = 4, tol, method, sqg)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([4.121292494689236;;], [-6.2062820378373225; -8.492711331361757; … ; -8.803154035363127e-6; 6.940272972117559e-6;;])</code></pre><p>And finally we can create our solution:</p><pre><code class="language-julia hljs"># Create grid and calculate streamfunctions and vorticities

grid = CreateGrid(Nx, Ny, Lx, Ly; cuda)
ψ, b = Calc_ψb(a, U, ℓ, R, β, grid)
u, v = Calc_uv(ψ, grid)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([-0.006452757393023565 -0.00645243932730151 … -0.006451481351865067 -0.006452439327300037; -0.0064532394293142295 -0.006452919498063193 … -0.006451963427183256 -0.006452919498061871; … ; -0.006454681807116567 -0.006454363780466202 … -0.006453405921540968 -0.006454363780464485; -0.0064532394293127125 -0.006452919498065082 … -0.0064519634271815235 -0.006452919498063473], [1.3184163483495778e-17 -5.0214976441434014e-17 … -1.4191922100611679e-16 6.884188617585033e-17; 1.2376954669784498e-17 9.622070532432837e-7 … -1.92445314459318e-6 -9.622070532289665e-7; … ; 1.2788701006773984e-17 -1.924453143465707e-6 … 3.848983835829158e-6 1.9244531435012994e-6; 1.3359844580104972e-17 -9.622070533737498e-7 … 1.9244531443414646e-6 9.62207053402925e-7])</code></pre><h2 id="Example-4:-Wrappers"><a class="docs-heading-anchor" href="#Example-4:-Wrappers">Example 4: Wrappers</a><a id="Example-4:-Wrappers-1"></a><a class="docs-heading-anchor-permalink" href="#Example-4:-Wrappers" title="Permalink"></a></h2><p>While the procedure outlined in Examples 1 to 3 gives an understanding our how this method works, it is often easier for users to be able to just call a single function to get the solution they want. Therefore, this package also includes wrappers for the SQG and LQG problems. Let&#39;s start with the LQG case and define some parameters:</p><pre><code class="language-julia hljs"># Set problem parameters

U, ℓ = 1, 1			# vortex speed and radius
R = [1, 1]			# Rossby radius in each layer
β = [0, 1]			# background PV gradient in each layer
ActiveLayers = [1, 1]		# 1 =&gt; layer contains vortex region
x₀ = [0, 0]			# position of vortex center

M = 8				# number of coefficients in Zernike expansion
tol = 1e-8			# maximum error in solution evaluation
cuda = false			# use CuArrays for grid
K₀, a₀ = [4, 4], Nothing	# guesses for K and a

# create grid

grid = CreateGrid(Nx, Ny, Lx, Ly; cuda)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">GridStruct(-5.0:0.01953125:4.98046875, -5.0:0.01953125:4.98046875, [0.0; 0.6283185307179586; … ; 160.22122533307945; 160.8495438637974;;], [0.0 0.6283185307179586 … -1.2566370614359172 -0.6283185307179586], [0.0 0.3947841760435743 … 1.5791367041742972 0.3947841760435743; 0.3947841760435743 0.7895683520871486 … 1.9739208802178716 0.7895683520871486; … ; 25670.841047233418 25671.23583140946 … 25672.420183937593 25671.23583140946; 25872.575761191685 25872.970545367727 … 25874.15489789586 25872.970545367727])</code></pre><p>Most of these have been described in previous examples, but <span>$K_0$</span> and <span>$\textbf{a}$</span> are new. These are the initial guesses for <span>$K$</span> and <span>$\textbf{a}$</span> and are not required. They can be useful when doing a parameter sweep; since values from a case with similar parameters can be used to speed up the root-finding step for the new parameter case. In general, <span>$K = 4$</span> is a good guess for most LQG and SQG vortices. In principle, there are a (countably) infinite set of solutions with increasing radial mode number. The solutions we normally think of as dipolar vortices are the first mode and higher modes are generally unstable<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>.</p><p>Now we have our parameters, we can get our vortex solution with a single function call:</p><pre><code class="language-julia hljs"># create modon solution

ψ, q, K, a = CreateModonLQG(grid, M, U, ℓ, R, β, ActiveLayers, x₀; K₀, a₀, tol)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([-4.141324760117843e-18 0.00016779003441907227 … -0.000335568451976269 -0.00016779003441907004; -3.807894946254001e-18 0.00016780798967804813 … -0.0003356043637737148 -0.00016780798967804542; … ; -4.801053750859226e-18 0.0001678618567346654 … -0.0003357121017268013 -0.00016786185673466438; -4.4726671601502685e-18 0.00016780798967804737 … -0.00033560436377371534 -0.00016780798967804567;;; -5.4664408857198335e-18 0.00010410529410505927 … -0.00020820351525801866 -0.00010410529410507396; -5.8215781488638805e-18 0.00010411654014973068 … -0.00020822600821258864 -0.00010411654014974445; … ; -4.741285144059175e-18 0.00010415027914909613 … -0.00020829348880786874 -0.00010415027914911249; -5.105724747550771e-18 0.0001041165401497293 … -0.00020822600821258767 -0.00010411654014974477], [-1.8206727018152385e-19 1.4917713979960205e-16 … -2.168952269408764e-17 -5.10537230643933e-17; 6.6079305068560316e-18 1.400556738962812e-16 … -1.468338079850937e-17 -6.273626449356161e-17; … ; -1.3904968840543563e-17 1.708459067941874e-16 … -3.3462838601766e-17 -3.430339785983988e-17; -6.972065047219048e-18 1.5938159871004823e-16 … -2.777020876819079e-17 -4.1010018222639357e-17;;; -5.7266820673118864e-18 0.00010410529410510069 … -0.00020820351525793898 -0.0001041052941046978; -1.5357278572130027e-18 0.00010411654014979074 … -0.00020822600821251232 -0.00010411654014934237; … ; -1.4591546227018968e-17 0.00010415027914909715 … -0.00020829348880778057 -0.00010415027914878721; -9.912057402385757e-18 0.00010411654014975056 … -0.0002082260082125031 -0.00010411654014939422], [3.8002227321819118 3.9498636644089475], [-8.740402597582975 -12.363296148042721; -11.099180304721193 -15.939788930861885; … ; -1.286718502304096e-5 -2.2391206648496783e-5; -2.360366577747186e-7 -4.194145386549053e-7])</code></pre><p>The SQG wrapper is similar. We start by defining our paramters:</p><pre><code class="language-julia hljs"># Set problem parameters

U, ℓ = 1, 1			# vortex speed and radius
R = [Inf, Inf]			# Baroclinic and Barotropic Rossby radii
β = 0				# background PV gradient in the interior
x₀ = [0, 0]			# position of vortex center

M = 20				# number of coefficients in Zernike expansion
tol = 1e-6			# maximum error in solution evaluation
cuda = false			# use CuArrays for grid
K₀, a₀ = 8, Nothing		# guesses for K and a

# Set grid parameters

Nx, Ny = 512, 512
Lx, Ly = 10, 10

# create grid

grid = CreateGrid(Nx, Ny, Lx, Ly; cuda)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">GridStruct(-5.0:0.01953125:4.98046875, -5.0:0.01953125:4.98046875, [0.0; 0.6283185307179586; … ; 160.22122533307945; 160.8495438637974;;], [0.0 0.6283185307179586 … -1.2566370614359172 -0.6283185307179586], [0.0 0.3947841760435743 … 1.5791367041742972 0.3947841760435743; 0.3947841760435743 0.7895683520871486 … 1.9739208802178716 0.7895683520871486; … ; 25670.841047233418 25671.23583140946 … 25672.420183937593 25671.23583140946; 25872.575761191685 25872.970545367727 … 25874.15489789586 25872.970545367727])</code></pre><p>Note that we&#39;ve used <span>$K_0 = 8$</span> this time. We&#39;ll see what happens when we create and plot our solution:</p><pre><code class="language-julia hljs"># create modon solution

ψ, b, K, a = CreateModonSQG(grid, M, U, ℓ, R, β, x₀; K₀, a₀, tol)

using Plots

heatmap(grid.x, grid.y, transpose(ψ);
    colormap = :balance,
    aspect_ratio=1,
    xlims = (-Lx/2, Lx/2),
    ylims = (-Ly/2, Ly/2))</code></pre><img src="fbc733f8.svg" alt="Example block output"/><p>If we look at <span>$K$</span>, we find that <span>$K \approx 7.34205$</span> which is not the value we&#39;d expect for the usual dipole solution. Instead, if we look at our plot, we see that it&#39;s a different solution with a mode 2 structure in the radial direction.</p><p>In addition to these wrapper functions, the functions <code>CreateLCD</code> and <code>CreateLCD</code> implement the Lamb-Chaplygin dipole<sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup> and Larichev-Reznik dipole<sup class="footnote-reference"><a id="citeref-3" href="#footnote-3">[3]</a></sup> directly using the analytical solution for these cases.</p><h2 id="Example-5:-A-GeophysicalFlows.jl-simulation"><a class="docs-heading-anchor" href="#Example-5:-A-GeophysicalFlows.jl-simulation">Example 5: A GeophysicalFlows.jl simulation</a><a id="Example-5:-A-GeophysicalFlows.jl-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Example-5:-A-GeophysicalFlows.jl-simulation" title="Permalink"></a></h2><p>This package is designed to be compatible with <code>GeophysicalFlows.jl</code><sup class="footnote-reference"><a id="citeref-4" href="#footnote-4">[4]</a></sup> and provide a means of generating dipolar vortex initial conditions for layered QG and surface QG simulations. Here, we&#39;ll discuss a simple example of how to setup a 1-layer simulation in <code>GeophyiscalFlows.jl</code> using the Lamb-Chaplygin dipole as the initial condition. We&#39;ll also see that, as expected, the dipole retains it&#39;s form during the evolution and hence is a steady solution in a co-moving frame. Let&#39;s begin by defining some parameters for our vortex initial condition and our numerical simulation:</p><pre><code class="language-julia hljs">using GeophysicalFlows, QGDipoles

# Define vortex parameters

U, ℓ = 1, 1

# Set numerical simulation parameters

nx, ny = 1024, 1024
Lx, Ly = 20.48, 20.48
T = 10                        # simulation stop time
Δt = 0.01                     # timestep
Nt = Int(T/Δt)				  # number of timesteps
dev = GPU()
stepper = &quot;FilteredRK4&quot;
</code></pre><p><code>GeophysicalFlows.jl</code> allows simulations to be run on a GPU so we&#39;ve set <code>dev = CPU()</code> to use this functionality. <code>QGDipoles.jl</code> will construct vortex solutions as <code>CuArrays</code> using <code>CUDA</code> when given a grid that is stored on a GPU. We can now define our problem using the <code>SingleLayerQG</code> module from <code>GeophysicalFlows.jl</code>. This problem will contain a grid (<code>prob.grid</code>) that can be passed to functions from <code>QGDipoles.jl</code> in the same manner as grids contructed using <code>CreateGrid</code>.</p><pre><code class="language-julia hljs"># Define problem using SingleLayerQG from GeophysicalFlows.jl

prob = SingleLayerQG.Problem(dev;
		nx,
		ny,
		Lx,
		Ly,
		U = -U,			# background flow so vortex remains stationary
		dt = Δt,
		stepper)
</code></pre><p>Here, we&#39;ve used a background flow which moves in the opposite direction to the vortex and with the same magnitude, <code>U</code>. Therefore, we&#39;re working in a frame co-moving with the vortex and we expect it to remain centred on the orogin throughout the evolution. Next, we&#39;ll use <code>CreateLCD</code> to create a Lamb-Chaplygin dipole and use this as our initial condition.</p><pre><code class="language-julia hljs"># Set initial condition

_, q₀, K = CreateLCD(prob.grid, U, ℓ)
q₀ = reshape(q₀, nx, ny)		# convert from size (nx, ny, 1) to size (nx, ny)
SingleLayerQG.set_q!(prob, q₀)

# Define Energy as a diagnostic for the simulation

diags = Diagnostic(SingleLayerQG.energy, prob; nsteps=Nt, freq=Int(Nt/100))
</code></pre><p>We&#39;ve also defined a <code>Diagnostic</code> which will save the domain-averaged energy during the simulation. Finally, we can evolve the simulation in time:</p><pre><code class="language-julia hljs"># Evolve system forward in time

stepforward!(prob, diags, Nt)
SingleLayerQG.updatevars!(prob)
</code></pre><p>We can plot our initial condition and solution at <span>$t = 10.0$</span> using:</p><pre><code class="language-julia hljs">using Plots

heatmap(prob.grid.x, prob.grid.y, device_array(CPU())(transpose(q₀));
		colormap = :balance,
		aspect_ratio=1,
		xlims = (-Lx/2, Lx/2),
		ylims = (-Ly/2, Ly/2))

heatmap(prob.grid.x, prob.grid.y, device_array(CPU())(transpose(prob.vars.q));
		colormap = :balance,
		aspect_ratio=1,
		xlims = (-Lx/2, Lx/2),
		ylims = (-Ly/2, Ly/2))
</code></pre><p>Note that we need to move our fields back to the CPU prior to plotting. The two plots are shown below and are approximately identical. Therefore, we observe that the vortex remains centred at the origin. Over long times, numerical error will result in the vortex moving at a slightly different speed to <code>U</code> and hence moving away from the origin.</p><p><img src="../Ex_5a.png" alt="image"/><img src="../Ex_5b.png" alt="image"/></p><p>See the <code>GeophyiscalFlows.jl</code> documentation <a href="https://fourierflows.github.io/GeophysicalFlowsDocumentation/stable/">here</a> for more details on how to run QG simulations.</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a><a href="https://doi.org/10.1017/jfm.2023.87">Johnson, E. R., and M. N. Crowe, 2023, Oceanic dipoles in a surface quasigeostrophic model, J. Fluid Mech., 958, R2</a>.</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a><a href="https://archive.org/details/hydrodynamics00lamb">Lamb, H., 1932, Hydrodynamics. Cambridge University Press</a>.</li><li class="footnote" id="footnote-3"><a class="tag is-link" href="#citeref-3">3</a><a href="https://www.researchgate.net/publication/248173065_Two-dimensional_solitary_Rossby_waves">Larichev, V.D. &amp; Reznik, G.M., 1976, Two-dimensional solitary Rossby waves, Dokl. Akad. Nauk SSSR, 12–13</a>.</li><li class="footnote" id="footnote-4"><a class="tag is-link" href="#citeref-4">4</a><a href="https://joss.theoj.org/papers/10.21105/joss.03053">Constantinou et al., 2021, GeophysicalFlows.jl: Solvers for geophysical fluid dynamics problems in periodic domains on CPUs &amp; GPUs, JOSS, 6(60), 3053</a>.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../Functions/">List of Functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Tuesday 5 November 2024 12:26">Tuesday 5 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
