var documenterSearchIndex = {"docs":
[{"location":"Methodology/#Methodology","page":"Methodology","title":"Methodology","text":"","category":"section"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"This page contains a summary of the numerical method used to determine steady dipolar solutions to quasi-geostrophic systems. A summary of the notation used is also included below.","category":"page"},{"location":"Methodology/#Method-Summary","page":"Methodology","title":"Method Summary","text":"","category":"section"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"This package is based on the semi-analytic theory of dipolar vortices derived in Johnson & Crowe 2023[1] and Crowe & Johnson 2023[2] for SQG solutions and Crowe & Johnson 2024[3] for LQG solutions. A summary is presented here such that the notation and examples presented elsewhere make some sense. We consider a dipolar vortex of radius ell, moving with speed U. This vortex consists of an isolated region of high vorticity with a closed streamline at x^2 + y^2 = ell^2 (in a frame co-moving with the vortex), hence fluid does not escape during propagation. Within the vortex core, x^2 + y^2  ell^2, are two counter rotating regions, corresponding to a dipole. The streamfunction describing the flow is denoted by psi and potential vorticity (PV) anomaly by q. Velocities may be derived as (u v) = (-partial_ypsi partial_xpsi). The streamfunction, psi, and PV anomaly, q, are related through PV inversion. In the case of multiple layers, psi and q are vector valued functions of length equal to the number of layers, N.","category":"page"},{"location":"Methodology/#Layered-Quasi-Geostrophic-(LQG)-Solutions","page":"Methodology","title":"Layered Quasi-Geostrophic (LQG) Solutions","text":"","category":"section"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"In the LQG model, steady, propagating, dipolar vortices satisfy the relation","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"q_i + beta_i y = F_i(psi_i + Uy)","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"where beta_i denotes the background PV gradient, i in 1dotsN is the layer index and F_i is an arbitrary (piecewise continuous) function. To proceed, we assume that F_i(z) = (beta_iU) z for x^2 + y^2  ell^2 (outside the vortex) and F_i(z) = -(K_i^2ell^2) z for x^2 + y^2  ell^2 (inside the vortex). Using a Hankel transform and expansion in term of Zernike radial functions, the problem may be reduced to the linear algebra system","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"left textbfA -  sum _n = 1^N K_n^2textbfB_n right textbfa = textbfc_0 + sum _n = 1^N K_n^2 textbfc_n","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"where textbfA and textbfB_n are matrices, textbfa is a vector containing the coefficients in the polynomial expansion, textbfc_j are vectors and the K_n are defined in F_i above and appear as unknown eigenvalues in the linear problem. In order to solve the system, N additional conditions are required. These are textbfd_n cdot textbfa = 0 for n in 1 dots N where the textbfd_n are vectors. These conditions correspond to the requirement that the streamfunction and vorticity are continuous in each layer. In principal, we have an infinite number of coefficients in textbfa. However, since we know that these coefficients must decay with increasing index (since psi is continuous), we can truncate the expansion after M terms. The resulting linear system is of size MN times MN.","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"Solving this system determines the expansion coefficients and eigenvalues and hence allows psi and q to be evaluated on any given spatial grid. In the one-layer case the problem reduces to known analytical solutions, such as the Lamb-Chaplygin dipole[4] and the Larichev-Reznik dipole[5].","category":"page"},{"location":"Methodology/#Surface-Quasi-Geostrophic-(SQG)-Solutions","page":"Methodology","title":"Surface Quasi-Geostrophic (SQG) Solutions","text":"","category":"section"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"In the SQG model, steady, propagating, dipolar vortices satisfy the relation","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"leftpartial_z + frac1Rright psi = F(psi + Uy)","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"where","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"partial_z = sqrt-nabla^2 + betaU hspace5pt tanh leftR sqrt-nabla^2 + betaU right","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"is a Dirichlet-Neumann operator linking the surface streamfunction, psi, and the surface buoyancy, b = partial_z psi. Here, (R R) describes the baroclinic and barotropic Rossby radii and beta is the background vorticity gradient. We assume that F(z) = 0 for x^2 + y^2  ell^2 (outside the vortex) and F_i(z) = -(Kell) z for x^2 + y^2  ell^2. Using a Hankel transform and expansion in term of Zernike radial functions, the problem may be reduced to the linear algebra system","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"left textbfA -  KtextbfB right textbfa = textbfc_0 + K textbfc_1","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"where textbfA and textbfB are matrices, textbfc_i are vectors, textbfa is a vector of coefficients and K is an eigenvalue related to F. An additional condition is required to solve this system for a unique set of K. This condition is taken to be continuity across the vortex boundary and corresponds to textbfd cdot textbfa = 0 for some vector textbfd. In principal, we have an infinite number of coefficients in textbfa. However, since we know that these coefficients must decay with increasing index (since psi is continuous), we can truncate the expansion after M terms. The resulting linear system is of size M times M.","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"Solving this linear system allows the surface streamfunction, psi, and surface bouyancy, b, to be calculated.","category":"page"},{"location":"Methodology/#Solving-the-Linear-System","page":"Methodology","title":"Solving the Linear System","text":"","category":"section"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"Consider the multi-parameter, inhomogeneous eigenvalue problem","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"left textbfA -  sum _n = 1^N K_n^mtextbfB_n right textbfa = textbfc_0 + sum _n = 1^N K_n^m textbfc_n quad textrmst quad textbfd_n cdot textbfa = 0 quad textrmfor quad n in 1 dots N","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"which describes both the SQG (m N = 1) and LQG (m = 2) systems. For N = 1, this system may be converted into a quadratic eigenvalue problem and solved by standard techniques. For N  1, existing techniques scale poorly with matrix size so we take an alternative approach and find (K textbfa) using a root finding method, where the orthogonality conditions (textbfd_n cdot textbfa = 0) are used to reduce the dimension of the space. These two approaches are described in the Appendix of Crowe & Johnson 2024[3].","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"Further details on solving the multi-parameter, ingomogeneous eigenvalue problem are given here using a MATLAB demonstration.","category":"page"},{"location":"Methodology/#Recovering-the-Vortex-Solution","page":"Methodology","title":"Recovering the Vortex Solution","text":"","category":"section"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"Once the coefficients are determined, they are multiplied by the basis polynomials and summed on a specified numerical grid to give an intermediate field, textbfF. The streamfunction, psi, potential vorticity anomaly, q (LQG), and surface buoyancy, b (SQG), are related to textbfF by differential operators and may be calculated using discrete Fourier transforms. Note that the streamfunction may decay slowly in the far-field for certain parameters so a sufficiently large domain is required to avoid Gibbs phenemenon near the domain edges.","category":"page"},{"location":"Methodology/#Equations-and-Parameters","page":"Methodology","title":"Equations and Parameters","text":"","category":"section"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"This section contains a summary of the LQG and SQG systems of equations and tables which summarise all parameters used in functions and structures of QGDipoles.jl.","category":"page"},{"location":"Methodology/#The-LQG-System","page":"Methodology","title":"The LQG System","text":"","category":"section"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"The layered QG equations are","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"(partial_t - U partial_x) q_i + J(psi_iq_i) + beta_i partial_x psi_i = 0 quad i in 12dots N","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"where the potential vorticity in each layer, q_i, is given in terms of the streamfunction in each layer, psi_i, by","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"beginalign*\nq_1 =  nabla^2 psi_1 + R_1^-2 (psi_2 - psi_1)\nq_i =  nabla^2 psi_i + R_i^-2 (psi_i-1-2psi_i+psi_i+1) quad i in 2dots N-1\nq_N =  nabla^2 psi_N  + R_N^-2 (psi_N-1-psi_N)\nendalign*","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"and R_i = sqrtgH_if is the Rossby radius of deformation in each layer. The full list of parameters for the LQG system is given in the table below.","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"Parameter Description Definition\nU vortex speed -\nell vortex radius -\nbeta background (y) vorticity gradient in each layer -\nR Rossby radius in each layer R_i = sqrt gH_i  f\nlambda ratio of radius to R in each layer lambda_i = ell  R_i\nmu rescaled vorticity gradient mu_i = beta_i ell^2  U\nalpha angle of vortex propagation -\nx_0 position of vortex center -\nN number of layers -\nM number of terms in polynomial expansion -\ng buoyancy difference between each layer -\nf Coriolis parameters -\nH layer depth in each layer -","category":"page"},{"location":"Methodology/#The-SQG-System","page":"Methodology","title":"The SQG System","text":"","category":"section"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"The 3D QG equations are","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"(partial_t - U partial_x) q + J(psiq) + beta partial_x psi = 0 quad textrmfor quad z in -R 0","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"where","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"q = leftfracpartial^2partial x^2 + fracpartial^2partial y^2 + fracpartial^2partial z^2right psi quad textrmfor quad z in -R 0","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"and R = NHf is the Baroclinic Rossby radius. Note that we have rescaled z by Nf so q and psi are related by the 3D Laplacian operator. The top boundary condition is taken to be","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"(partial_t - U partial_x) b + N^2 eta + J(psi b + N^2 eta) = 0 quad textrmon quad z  = 0","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"and we assume that b = 0 on the bottom surface, z = -R. Here, b = N partialpsipartial z is the buoyancy and eta = fpsig is the surface elevation.","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"The SQG system is typically derived by assuming that q = 0 in the interior. We instead take q = (betaU)psi which satisfies the steady evolution equation for q given above and reduces to the usual result for beta = 0. Since b(z = 0) can be determined from psi(z = 0) using the Dirichlet-Neumann operator given above, this system reduces to a 2D system for the modified surface buoyancy, b + N^2 eta, only.","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"QGDipoles.jl solves for steady, dipolar solutions to this surface equation and hence calculates only the surface values of b and psi using Calc_ψb or CreateModonSQG. If a 3D solution is required, the functions Eval_ψ_SQG, Eval_q_SQG and Eval_b_SQG can be used to calculate ψ, q and b at specified depths. Alternatively, a layered model with a large number of layers can be used to model the continuous system. The full list of parameters for the SQG system is given in the table below.","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"Note: this package returns bN rather than b. When working with dimensional variables, this factor of 1N should be included manually.","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"Parameter Description Definition\nU vortex speed -\nell vortex radius -\nbeta background (y) vorticity gradient in each layer -\nR baroclinic Rossby radius R = NH  f\nR reduced barotropic Rossby radius R = R_0^2  R\nlambda ratio of radius to R lambda = ell  R\nmu rescaled vorticity gradient mu = beta ell^2  U\nalpha angle of vortex propagation -\nx_0 position of vortex center -\nM number of terms in polynomial expansion -\nN buoyancy frequency -\nR_0 barotropic Rossby radius R_0 = sqrt gH  f\ng gravitational acceleration -\nf Coriolis parameters -\nH layer depth -","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"[1]: Johnson, E. R., and M. N. Crowe, 2023, Oceanic dipoles in a surface quasigeostrophic model, J. Fluid Mech., 958, R2.","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"[2]: Crowe, M. N., and E. R. Johnson, 2023, The evolution of surface quasi-geostrophic modons on sloping topography, J. Fluid. Mech., 970, A10.","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"[3]: Crowe, M. N., and E. R. Johnson, 2024, Modon solutions in an N-layer quasi-geostrophic model, J. Fluid. Mech., 994, R1.","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"[4]: Lamb, H., 1932, Hydrodynamics. Cambridge University Press.","category":"page"},{"location":"Methodology/","page":"Methodology","title":"Methodology","text":"[5]: Larichev, V.D. & Reznik, G.M., 1976, Two-dimensional solitary Rossby waves, Dokl. Akad. Nauk SSSR, 12–13.","category":"page"},{"location":"FAQ/#Frequently-Asked-Questions-(FAQ)","page":"FAQ","title":"Frequently Asked Questions (FAQ)","text":"","category":"section"},{"location":"FAQ/#How-do-I-access-fields-inside-the-vortex-and-parameter-structures?","page":"FAQ","title":"How do I access fields inside the vortex and parameter structures?","text":"","category":"section"},{"location":"FAQ/","page":"FAQ","title":"FAQ","text":"We can access the fields of a vortex or parameter structure using a dot . followed by the field we want. For example the following returns the array b from an SQGVortex structure","category":"page"},{"location":"FAQ/","page":"FAQ","title":"FAQ","text":"vortex.b","category":"page"},{"location":"FAQ/","page":"FAQ","title":"FAQ","text":"A full list of all fields for each structure is available on the List of Functions page.","category":"page"},{"location":"FAQ/#How-do-I-set-up-solutions-on-a-GPU?","page":"FAQ","title":"How do I set up solutions on a GPU?","text":"","category":"section"},{"location":"FAQ/","page":"FAQ","title":"FAQ","text":"Passing the keyword cuda = true to CreateGrid will create a grid on a GPU. Any vortex solutions calculated using this grid will also be stored on the GPU.","category":"page"},{"location":"FAQ/#How-do-I-control-the-accuracy-of-vortex-solutions?","page":"FAQ","title":"How do I control the accuracy of vortex solutions?","text":"","category":"section"},{"location":"FAQ/","page":"FAQ","title":"FAQ","text":"The keywords M and tol both relate to accuracy. M determines the number of coefficients in the Zernike polynomial expansion used to determine the solution while tol determines the tolerance used when building and solving the underlying linear algebra problem. It is recommended to set the required tolerance first, then examine the coefficients in the resulting solution. Any coefficients less than the tolerance are set to zero so you should take the minimum M such that all coefficients are non-zero. The default parameters of tol = 1e-6 and M = 8 (LQG) and M = 12 (SQG) are generally sufficient.","category":"page"},{"location":"FAQ/#What-grid-limits-can-I-use?","page":"FAQ","title":"What grid limits can I use?","text":"","category":"section"},{"location":"FAQ/","page":"FAQ","title":"FAQ","text":"The grid limits may be set using the Lx and Ly arguments/keywords. Setting these to scalars, e.g. Lx = 10, will give a grid where x ∈ [-Lx/2, Lx/2] and/or y ∈ [-Ly/2, Ly/2] and entering vector arguments, e.g. Ly = [-4, 4], will give a grid where x ∈ [Lx[1], Lx[2]] and/or y ∈ [Ly[1], Ly[2]]. We can also enter, for example, Lx as a scalar and Ly as a vector.","category":"page"},{"location":"FAQ/#How-do-I-set-the-initial-position-and-angle-of-the-vortex?","page":"FAQ","title":"How do I set the initial position and angle of the vortex?","text":"","category":"section"},{"location":"FAQ/","page":"FAQ","title":"FAQ","text":"The keywords x₀ and α may be used to set the initial position and angle of the vortex. The angle is measured anti-clockwise from the positive x axis and defined such that the vortex will travel in this direction with speed U.","category":"page"},{"location":"FAQ/#Can-I-change-the-method-used-for-solving-the-eigenvalue-problem?","page":"FAQ","title":"Can I change the method used for solving the eigenvalue problem?","text":"","category":"section"},{"location":"FAQ/","page":"FAQ","title":"FAQ","text":"Yes, you can change the method but only for single layer (including SQG) solutions. In this case, the two available methods are","category":"page"},{"location":"FAQ/","page":"FAQ","title":"FAQ","text":"Nonlinear root finding: root-finding is used to determine the eigenvalue and eigenvector given an initial guess.\nGeneralised eigenvalue methods: the underlying problem is converted to a generalised eigenvalue problem and solved using standard methods.","category":"page"},{"location":"FAQ/","page":"FAQ","title":"FAQ","text":"The choice of method can be specified using the low-level function SolveInhomEVP with the keyword method. method = :eigensolve corresponds to the generalised eigenvalue method while method = :nlsolve corresponds to nonlinear root finding.","category":"page"},{"location":"FAQ/#How-do-I-examine-the-underlying-linear-system?","page":"FAQ","title":"How do I examine the underlying linear system?","text":"","category":"section"},{"location":"FAQ/","page":"FAQ","title":"FAQ","text":"The low-level functions allow you to build the linear system explicitly. See the examples here for more details.","category":"page"},{"location":"FAQ/#How-do-I-calculate-energy/enstrophy-for-a-given-vortex?","page":"FAQ","title":"How do I calculate energy/enstrophy for a given vortex?","text":"","category":"section"},{"location":"FAQ/","page":"FAQ","title":"FAQ","text":"Various diagnostics can be calculated for a given vortex solution using integrals over the domain given by the grid. The available diagnostics are given here. Diagnostics may be calculated directly using high-level functions or may be calculated as part of a vortex structure by setting the relevant keywords to true as shown here.","category":"page"},{"location":"FAQ/#How-do-I-calculate-velocity/vorticity/gradients?","page":"FAQ","title":"How do I calculate velocity/vorticity/gradients?","text":"","category":"section"},{"location":"FAQ/","page":"FAQ","title":"FAQ","text":"The functions Calc_uv, Calc_ζ, and Calc_∇ may be used to calculate velocities, vorticity and gradients respectively.","category":"page"},{"location":"Examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Here we present some examples which demonstrate how to use this package. Further examples are available in the examples/ directory here.","category":"page"},{"location":"Examples/#Getting-Started","page":"Examples","title":"Getting Started","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The first step is to create a new project (also known as an environment) and install Julia. We can do this by opening Julia with the current directory enabled using","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"julia --project=.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Further information on working with environments can be found here.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"We can now install QGDipoles.jl to this project using the instructions on the Installation page. It is strongly recommended to install QGDipoles.jl and all other packages required for a particular project to a new environment for that project.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"To run the examples on this page we'll also need Plots.jl which can be installed using","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"import Pkg\nPkg.add(\"Plots\")\nPkg.instantiate()","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"One of the examples below also requires GeophysicalFlows.jl which can be installed in the same way.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"We can now follow the examples below or copy the examples/ directory to our current working directory using","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"using QGDipoles\ncp(joinpath(pkgdir(QGDipoles), \"examples\"), \"examples\")","category":"page"},{"location":"Examples/#Example:-Vortex-Structures","page":"Examples","title":"Example: Vortex Structures","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The recommended way to use QGDipoles.jl for new users is to create vortex structures. Let's create a single-layer QG vortex with unit radius and velocity ℓ = U = 1 and impose a background rotation gradient of β = 1. We'll start by creating a grid by specifying the number of gridpoints (Nx, Ny) and the domain size (Lx, Ly)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"using QGDipoles, Plots\n\ngrid = CreateGrid(; Nx = 512, Ny = 512, Lx = 10, Ly = 10)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"We can now use this grid to create our vortex","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"vortex = DefLQGVortex(grid; U = 1, ℓ = 1, β = 1)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"This function call may take a few seconds as Julia functions are compiled before they're used for the first time. Subsequent calls of the same function will be much faster. Vortex parameters are passed as keyword arguments, the full list of keyword arguments available for each function can be found on the List of Functions page. Strictly, we don't need to include ℓ and U here as 1 is the default for these keywords. Our vortex solution can be plotted as a heatmap using","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"heatmap(grid, vortex.ψ)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"We can now modify our vortex by including a finite Rossby radius of deformation (corresponding to the equivalent barotropic model) given by R = 1","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"vortex = UpdateVortex(grid, vortex; R = 1)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"All other parameters remain unchanged and can be checked using","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"vortex.params","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"We can construct two-layer QG vortices and SQG vortices using the same approach","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"vortex_LQG = DefLQGVortex(grid; R = [1, 1], β = [1, 0])\n\nvortex_SQG = DefSQGVortex(grid)\n\nnothing # hide","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"We can plot layers from multi-layer vortices using the layer keyword in heatmap.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"By default, the streamfunction, ψ, and potential vorticity anomaly, q, are calculated for layered QG solutions while the surface streamfunction ψ, and surface buoyancy, b, are calculated for SQG solutions. We can calculate additional quantities, such as the velocity and energy, by setting the relevant keywords to true. Here we plot the velocity components for an SQG vortex and display the associated (domain-integrated) energy","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"vortex = DefSQGVortex(grid; CalcVelocity = true, CalcEnergy = true)\n\nplot(heatmap(grid, vortex.u, colorlimits=(-10, 10)), heatmap(grid, vortex.v))","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"println(vortex.E)","category":"page"},{"location":"Examples/#Example:-High-Level-Functions","page":"Examples","title":"Example: High-Level Functions","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Instead of working with structures, we can also calculate vortrex solutions directly as arrays using both high-level and low-level functions. The high-level functions are wrappers for the low-level functionality and allow us to easily calculate solutions without having to uderstand the underlying linear algebra method.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Let's start with the LQG case, define some parameters and create the grid","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"using QGDipoles\n\n# Set problem parameters\n\nR = [1, 1]     # Rossby radius in each layer\nβ = [0, 1]     # background PV gradient in each layer\n\n# create grid\n\nNx, Ny = 512, 512\nLx, Ly = 10, 10\n\ngrid = CreateGrid(Nx, Ny, Lx, Ly)\n\nnothing # hide","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Now we have our parameters and grid, we can get our vortex solution with a single function call","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# create modon solution\n\nψ, q, K, a = CreateModonLQG(grid; R, β)\n\nnothing # hide","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The SQG wrapper is similar. We start by defining some paramters","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# Set problem parameters\n\nM = 20    # number of coefficients in Zernike expansion\nK₀ = 8    # guess for K\n\n# create grid\n\nNx, Ny = 512, 512\nLx, Ly = 10, 10\n\ngrid = CreateGrid(Nx, Ny, Lx, Ly)\n\nnothing # hide","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Note that we've set K_0 = 8 this time. We'll see what happens when we create and plot our solution:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# create modon solution\n\nψ, b, K, a = CreateModonSQG(grid; M, K₀)\n\nK","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"using Plots\n\nheatmap(grid, ψ)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The parameter K is an eigenvalue in the underlying linear algebra problem. There are a (countably) infinite set of vortex solutions and the value of K can be thought of as a radial wavenumber, with larger values of K corresponding to solutions with more complex radial structure. The solutions we normally think of as dipolar vortices are the lowest order mode and higher modes are generally unstable[1]. For both the LQG and SQG cases, the lowest order mode typically has a value of K approx 4 and by default the method looks for solutions with K approx 4. Setting K_0 allows us to specify the approximate value of K we want for our solution. If we look at K, we find that K = 734205 and if we look at our plot, we see that it's a solution with a mode 2 structure in the radial direction.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"In addition to these wrapper functions, the functions CreateLCD and CreateLRD implement the Lamb-Chaplygin dipole[2] and Larichev-Reznik dipole[3] directly using the analytical solution for these cases.","category":"page"},{"location":"Examples/#Example:-Low-Level-Functions","page":"Examples","title":"Example: Low-Level Functions","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Low-level functions are also available to calculate vortex solutions. In general, these allow more customisation than the high-level wrapper and vortex structures however some understanding of the underlying method is required to work with them effectively. Information on the methodology is given on the Methodology page and in the associated references.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Here we'll construct three different solutions using the low-level functions, namely a 1-Layer Dipole, a 3-Layer Vortex and an SQG Vortex.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"tip: Tip: GPU support\nWe support grid calculations on NVIDIA GPUs using the CUDA package. To use this functionality, pass cuda = true to the grid constructor. For example,grid = CreateGrid(Nx, Ny, Lx, Ly; cuda = true)","category":"page"},{"location":"Examples/#1-Layer-Dipole","page":"Examples","title":"1-Layer Dipole","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Let's calculate and plot the Larichev-Reznik dipole (LRD). This diople exists on the beta-plane in the equivalent barotropic model so we take beta = R = 1 and consider a 1-layer solution (N = 1). We'll also assume unit radius and velocity, ell = U = 1. Let's start by loading the package and defining some parameters","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"using QGDipoles, Plots\n\n# Set problem parameters\n\nU, ℓ = 1, 1\t# vortex speed and radius\nR = 1\t\t# Rossby radius in each layer\nβ = 1\t\t# background PV gradient in each layer\n\nM = 8\t\t# number of coefficients in Zernike expansion\ntol = 1e-8\t# maximum error in solution evaluation\n\n# Set grid parameters\n\nNx, Ny = 512, 512\nLx, Ly = 10, 10\n\nnothing # hide","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"We've taken M = 8 as this is generally a sufficient number of terms to get a relative error  10^-6 in the final result. The tolerance, tol, is used in calculating the terms in the linear system and a value of tol=10^{-8} corresponds to approximately the same error as our chosen M value. Here, we build a grid with 512 points in each direction and take the grid size to be 10 in each direction. We should always ensure that the grid size is sufficient to capture the far-field decay of the vortex in order to get accurate solutions. We can now build the linear system and solve for the coefficients as follows","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# Build and solve linear system for coefficients\n\nλ = ℓ / R\nμ = β * ℓ^2/U\n\nA, B, c, d = BuildLinSysLQG(M, λ, μ; tol)\nK, a = SolveInhomEVP(A, B, c, d; K₀ = 4, tol)\n\nnothing # hide","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The intermediate parameters, lambda and mu, describe the rescaled vortex radius and PV gradient. Finally, we can define a grid and evaluate our streamfunction, PV and velocities using","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# Create grid and calculate streamfunction, vorticity and velocities\n\ngrid = CreateGrid(Nx, Ny, Lx, Ly)\nψ, q = Calc_ψq(grid, a; U, ℓ, R, β)\nu, v = Calc_uv(grid, ψ)\n\nnothing # hide","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Our solution can now be plotted","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"heatmap(grid, ψ)","category":"page"},{"location":"Examples/#3-Layer-Vortex","page":"Examples","title":"3-Layer Vortex","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"This example considers a 3-layer solution and introduces the concept of active and passive layers. We define an active layer to be a layer with a closed streamline at x^2 + y^2 = ell^2 whereas a passive layer has no closed streamlines. Therefore, fluid within the vortex in an active layer remains trapped in the vortex. Conversely, fluid in the passive layer is not trapped in a vortex core but can still be affected through the change in layer thickness associated with the streamfunction in neighbouring layers. Passive layers have F_i(z) = (beta_iU) z everywhere and hence have no eigenvalue, K_i, to solve for. Further, the coefficients within a passive layer are zero though the solution may still be non-zero due to the coefficients in neighbouring layers. Therefore, the corresponding linear system can be simplified by removing rows and columns corresponding to passive layers and solving the reduced system for the active layers only.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"We'll start by defining some parameters","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"using QGDipoles\n\n# Set problem parameters\n\nU, ℓ = 1, 1\t\t\t# vortex speed and radius\nR = [1, 1, 1]\t\t\t# Rossby radius in each layer\nβ = [0, 0, 1]\t\t\t# background PV gradient in each layer\nActiveLayers = [0, 1, 0]\t# 1 => layer contains vortex region\nx₀ = [5, 5]\t\t\t# location of vortex center\n\nM = 8\t\t\t\t# number of coefficients in Zernike expansion\ntol = 1e-8\t\t\t# maximum error in solution evaluation\n\n# Set grid parameters\n\nNx, Ny = 512, 512\nLx, Ly = [0, 10], [0, 10]\n\nnothing # hide","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Here we've assumed that only the middle layer is active. Therefore our solution will describe a mid-depth propagating structure. We've also taken a background PV gradient in the lower layer only, to represent a PV gradient due to a topographic slope. Finally, we've taken our vortex to be centred at 5 5 and taken x and y to run from 0 to 10.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"We start by building the full linear system","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# Build and solve linear system for coefficients\n\nλ = ℓ ./ R\nμ = β * ℓ^2/U\n\nA, B, c, d = BuildLinSysLQG(M, λ, μ; tol)\n\nnothing # hide","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Next we remove the passive layers","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"A, B, c, d = ApplyPassiveLayers(A, B, c, d, ActiveLayers)\n\nnothing # hide","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"We can now solve the reduced system and put the passive layers, which have (K textbfa) = (0 textbf0), back in to ensure the sizes of K and textbfa match the number of layers","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"K, a = SolveInhomEVP(A, B, c, d; K₀ = 4, tol)\nK, a = IncludePassiveLayers(K, a, ActiveLayers)\n\nnothing # hide","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Finally, we can calculate our solution","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# Create grid and calculate streamfunctions and vorticities\n\ngrid = CreateGrid(Nx, Ny, Lx, Ly)\nψ, q = Calc_ψq(grid, a; U, ℓ, R, β, x₀)\n\nnothing # hide","category":"page"},{"location":"Examples/#SQG-Vortex","page":"Examples","title":"SQG Vortex","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"This example covers the SQG vortex and a few low-level solver options. The SQG problem requires a few changes to solver options, which we discuss below.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Start by setting parameters for the SQG vortex and grid, similar to previous examples:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"using QGDipoles\n\n# Set problem parameters\n\nU, ℓ = 1, 1     \t# vortex speed and radius\nβ = 0\t\t    \t# background PV gradient in the interior\n\n# Create grid\n\nNx, Ny = 512, 512\nLx, Ly = 10, 10\n\ngrid = CreateGrid(Nx, Ny, Lx, Ly)\n\nnothing # hide","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Despite the SQG problem having only 1-layer, here we enter R as a 2 element vector since we need both  the (reduced) barotropic and baroclinic Rossby radii, R and R. We'll take these as  and note that all functions accept infinite Rossby radii in both the SQG and LQG cases. However, R = 0 is not valid since the QG assumptions break down in this limit.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"R = [Inf, Inf]\t\t# Baroclinic and Barotropic Rossby radii\n\nnothing # hide","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The SQG problem also requires more coefficients to converge to the same accuracy as the LQG problem. Therefore, we take M = 20 here.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"M = 20\t\t    \t# number of coefficients in Zernike expansion\n\nnothing # hide","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The need for more coefficients is compensated by the fact that the SQG system is faster to calculate than the LQG system.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"We can use two different solution method for solving the SQG eigenvalue problem. These are:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"an eigenvalue method (method = :eigensolve),\nor a root-finding method (method = :nlsolve).","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"For the 1-layer LQG and SQG problems, the eigenvalue method will generally be faster (i.e. method = :eigensolve). For multi-layer problems, the root-finding method is always used (i.e. method = :nlsolve) as eigenvalue methods scale poorly with the number of layers. If you have a good initial guess for K and textbfa, you may be able to use method = :nlsolve to speed up the calculation in 1-layer LQG and SQG problems. The method flag is passed to the linear system solver, SolveInhomEVP.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"We'll use the root-finding method here.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"method = :nlsolve\n\nnothing # hide","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Next we can build the linear system","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# Build and solve linear system for coefficients\n\nλ = ℓ ./ R\nμ = β * ℓ^2/U\n\nA, B, c, d = BuildLinSysSQG(M, λ, μ)\nK, a = SolveInhomEVP(A, B, c, d; K₀ = 4, method, m = 1)\n\nnothing # hide","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"note: The exponent of K\nm is the exponent of K in the eigenvalue problem, K^m. The solver, SolveInhomEVP, assumes LQG by default, i.e. m=2. However, for SQG, we should use m=1.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Finally we can create our solution","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"ψ, b = Calc_ψb(grid, a; U, ℓ, R, β)\nu, v = Calc_uv(grid, ψ)\n\nnothing # hide","category":"page"},{"location":"Examples/#Example:-GeophysicalFlows.jl","page":"Examples","title":"Example: GeophysicalFlows.jl","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"QGDipoles.jl is designed to be compatible with GeophysicalFlows.jl[4] and provide a means of generating dipolar vortex initial conditions for layered QG and surface QG simulations. Here, we'll discuss a simple example of how to setup a 1-layer simulation in GeophyiscalFlows.jl using the Lamb-Chaplygin dipole as the initial condition. We'll also see that, as expected, the dipole retains it's form during the evolution and hence is a steady solution in a co-moving frame. Let's begin by defining some parameters for our vortex initial condition and our numerical simulation","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"using GeophysicalFlows, QGDipoles, Plots\n\n# Define vortex parameters\n\nU, ℓ = 1, 1\n\n# Set numerical simulation parameters\n\nnx, ny = 1024, 1024\nLx, Ly = 20.48, 20.48\nT = 10                  # simulation stop time\nΔt = 0.01               # timestep\nNt = Int(T/Δt)          # number of timesteps\ndev = CPU()             # device, change to GPU() if you have an Nvidia GPU\nstepper = \"FilteredRK4\"","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"GeophysicalFlows.jl allows simulations to be run on a GPU so we can set dev = GPU() to use this functionality. In this case, QGDipoles.jl will construct vortex solutions as CuArrays using CUDA when given a grid that is stored on a GPU. We can now define our problem using the SingleLayerQG module from GeophysicalFlows.jl. This problem will contain a grid (prob.grid) that can be passed to functions from QGDipoles.jl in the same manner as grids contructed using CreateGrid","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# Define problem using SingleLayerQG from GeophysicalFlows.jl\n\nprob = SingleLayerQG.Problem(dev;\n\t\tnx,\n\t\tny,\n\t\tLx,\n\t\tLy,\n\t\tU = -U,\t\t\t# background flow so vortex remains stationary\n\t\tdt = Δt,\n\t\tstepper)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Here, we've used a background flow which moves in the opposite direction to the vortex and with the same magnitude, U. Therefore, we're working in a frame co-moving with the vortex and we expect it to remain centred on the orogin throughout the evolution. Next, we'll use CreateLCD to create a Lamb-Chaplygin dipole and use this as our initial condition.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# Set initial condition\n\n_, q₀ = CreateLCD(prob.grid; U, ℓ)\nSingleLayerQG.set_q!(prob, q₀)\n\n# Define Energy as a diagnostic for the simulation\n\ndiags = Diagnostic(SingleLayerQG.energy, prob; nsteps=Nt, freq=Int(Nt/100))","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"We've also defined a Diagnostic which will save the domain-averaged energy during the simulation. Finally, we can evolve the simulation in time:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# Evolve system forward in time\n\nstepforward!(prob, diags, Nt)\nSingleLayerQG.updatevars!(prob)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"This step may take a couple of minutes to run on a CPU but will be much faster on a GPU. We can plot our initial condition and solution at t = 100 using:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"plot(heatmap(prob.grid, q₀), heatmap(prob.grid, prob.vars.q))","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The two plots are shown below and are approximately identical. Therefore, we observe that the vortex remains centred at the origin. Over long times, numerical error will result in the vortex moving at a slightly different speed to U and hence moving away from the origin.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"(Image: image)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"See the GeophyiscalFlows.jl documentation here for more details on how to run QG simulations.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"[1]: Johnson, E. R., and M. N. Crowe, 2023, Oceanic dipoles in a surface quasigeostrophic model, J. Fluid Mech., 958, R2.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"[2]: Lamb, H., 1932, Hydrodynamics. Cambridge University Press.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"[3]: Larichev, V.D. & Reznik, G.M., 1976, Two-dimensional solitary Rossby waves, Dokl. Akad. Nauk SSSR, 12–13.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"[4]: Constantinou et al., 2021, GeophysicalFlows.jl: Solvers for geophysical fluid dynamics problems in periodic domains on CPUs & GPUs, JOSS, 6(60), 3053.","category":"page"},{"location":"Functions/#Functions","page":"List of Functions","title":"Functions","text":"","category":"section"},{"location":"Functions/","page":"List of Functions","title":"List of Functions","text":"This page lists all Modules, Functions and Structures available in this package.","category":"page"},{"location":"Functions/#QGDipoles.jl-Module","page":"List of Functions","title":"QGDipoles.jl Module","text":"","category":"section"},{"location":"Functions/","page":"List of Functions","title":"List of Functions","text":"QGDipoles","category":"page"},{"location":"Functions/#QGDipoles","page":"List of Functions","title":"QGDipoles","text":"Package for creating steady modon solutions to the layered quasi-geostrophic equations and the surface quasi geostrophic equations.\n\nSee examples/ for example scripts and here for documentation.\n\n\n\n\n\n","category":"module"},{"location":"Functions/#Vortex-Structures","page":"List of Functions","title":"Vortex Structures","text":"","category":"section"},{"location":"Functions/#LQG","page":"List of Functions","title":"LQG","text":"","category":"section"},{"location":"Functions/","page":"List of Functions","title":"List of Functions","text":"LQGParams\nLQGVortex\nDefLQGParams\nDefLQGVortex","category":"page"},{"location":"Functions/#QGDipoles.LQGParams","page":"List of Functions","title":"QGDipoles.LQGParams","text":"LQGParams\n\nStores the parameters for an LQG dipolar vortex solution\n\nFields:\n\nU: Vortex speed\nℓ: Vortex radius\nR: Rossby radius\nβ: background PV gradient\nActiveLayers: 1 => layer contains vortex region\nH: thickness of each layer\nx₀: Vortex position\nα: Direction of vortex propagation\nM: number of coefficients in Zernike expansion\ntol: maximum error in solution evaluation\nK₀: initial guess for eigenvalue\na₀: initial guess for coefficients\nUseAnalytic: use analytic solution (1-layer only)\nCalcVelocity: flag to determine if velocity is calculated\nCalcVorticity: flag to determine if vorticity is calculated\nCalcEnergy: flag to determine if energy is calculated\nCalcEnstrophy: flag to determine if enstrophy is calculated\n\n\n\n\n\n","category":"type"},{"location":"Functions/#QGDipoles.LQGVortex","page":"List of Functions","title":"QGDipoles.LQGVortex","text":"LQGVortex\n\nStores fields and diagnostics for an LQG dipolar vortex solution\n\nFields:\n\nparams: Vortex params\nψ: streamfunction\nq: potential vorticity anomaly\nK: eigenvalue\na: coefficient matrix\nu: x velocity\nv: y velocity\nζ: vertical vorticity\nKE: kinetic energy\nPE: potential energy\nEN: enstrophy \n\n\n\n\n\n","category":"type"},{"location":"Functions/#QGDipoles.DefLQGParams","page":"List of Functions","title":"QGDipoles.DefLQGParams","text":"DefLQGParams(; U=1, ℓ=1, R=Inf, β=0, ActiveLayers=1, H=1, x₀=[0,0], α=0, M=8, tol=1e-6, K₀=nothing, a₀=nothing, UseAnalytic=false, CalcVelocity=false, CalcVorticity=false, CalcEnergy=false, CalcEnstrophy=false)\n\nDefines an LQGParams structure using the given inputs\n\nKeyword arguments:\n\nU: Vortex speed\nℓ: Vortex radius\nR: Rossby radius\nβ: background PV gradient\nActiveLayers: 1 => layer contains vortex region\nH: thickness of each layer\nx₀: Vortex position\nα: Direction of vortex propagation\nM: number of coefficients in Zernike expansion\ntol: maximum error in solution evaluation\nK₀: initial guess for eigenvalue\na₀: initial guess for coefficients\nUseAnalytic: use analytic solution (1-layer only)\nCalcVelocity: flag to determine if velocity is calculated\nCalcVorticity: flag to determine if vorticity is calculated\nCalcEnergy: flag to determine if energy is calculated\nCalcEnstrophy: flag to determine if enstrophy is calculated\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.DefLQGVortex","page":"List of Functions","title":"QGDipoles.DefLQGVortex","text":"DefLQGVortex(grid; U=1, ℓ=1, R=Inf, β=0, ActiveLayers=1, H=1, x₀=[0,0], α=0, M=8, tol=1e-6, K₀=nothing, a₀=nothing, UseAnalytic=false, CalcVelocity=false, CalcVorticity=false, CalcEnergy=false, CalcEnstrophy=false)\n\nDefines an LQGVortex solution structure using the given inputs\n\nArguments:\n\ngrid: grid structure\n\nKeyword arguments:\n\nU: Vortex speed\nℓ: Vortex radius\nR: Rossby radius\nβ: background PV gradient\nActiveLayers: 1 => layer contains vortex region\nH: thickness of each layer\nx₀: Vortex position\nα: Direction of vortex propagation\nM: number of coefficients in Zernike expansion\ntol: maximum error in solution evaluation\nK₀: initial guess for eigenvalue\na₀: initial guess for coefficients\nUseAnalytic: use analytic solution (1-layer only)\nCalcVelocity: flag to determine if velocity is calculated\nCalcVorticity: flag to determine if vorticity is calculated\nCalcEnergy: flag to determine if energy is calculated\nCalcEnstrophy: flag to determine if enstrophy is calculated\n\n\n\n\n\nDefLQGVortex(grid, params)\n\nDefines an LQGVortex solution structure using the given inputs\n\nArguments:\n\ngrid: grid structure\nparams: vortex parameters, LQGParams structure\n\n\n\n\n\n","category":"function"},{"location":"Functions/#SQG","page":"List of Functions","title":"SQG","text":"","category":"section"},{"location":"Functions/","page":"List of Functions","title":"List of Functions","text":"SQGParams\nSQGVortex\nDefSQGParams\nDefSQGVortex","category":"page"},{"location":"Functions/#QGDipoles.SQGParams","page":"List of Functions","title":"QGDipoles.SQGParams","text":"SQGParams\n\nStores the parameters for an SQG dipolar vortex solution\n\nFields:\n\nU: Vortex speed\nℓ: Vortex radius\nR: Rossby radius\nβ: background PV gradient\nx₀: Vortex position\nα: Direction of vortex propagation\nM: number of coefficients in Zernike expansion\ntol: maximum error in solution evaluation\nK₀: initial guess for eigenvalue\na₀: initial guess for coefficients\nCalcVelocity: flag to determine if velocity is calculated\nCalcVorticity: flag to determine if vorticity is calculated\nCalcEnergy: flag to determine if energy is calculated\n\n\n\n\n\n","category":"type"},{"location":"Functions/#QGDipoles.SQGVortex","page":"List of Functions","title":"QGDipoles.SQGVortex","text":"SQGVortex\n\nStores fields and diagnostics for an SQG dipolar vortex solution\n\nFields:\n\nparams: Vortex params\nψ: surface streamfunction\nb: surface buoyancy\nK: eigenvalue\na: coefficient matrix\nu: x velocity\nv: y velocity\nζ: vertical vorticity\nE: domain integrated energy\nSPE: surface potential energy\n\n\n\n\n\n","category":"type"},{"location":"Functions/#QGDipoles.DefSQGParams","page":"List of Functions","title":"QGDipoles.DefSQGParams","text":"DefSQGParams(; U=1, ℓ=1, R=[Inf,Inf], β=0, x₀=[0,0], α=0, M=12, tol=1e-6, K₀=nothing, a₀=nothing, CalcVelocity=false, CalcVorticity=false, CalcEnergy=false)\n\nDefines an SQGParams structure using the given inputs\n\nKeyword arguments:\n\nU: Vortex speed\nℓ: Vortex radius\nR: Rossby radius\nβ: background PV gradient\nx₀: Vortex position\nα: Direction of vortex propagation\nM: number of coefficients in Zernike expansion\ntol: maximum error in solution evaluation\nK₀: initial guess for eigenvalue\na₀: initial guess for coefficients\nCalcVelocity: flag to determine if velocity is calculated\nCalcVorticity: flag to determine if vorticity is calculated\nCalcEnergy: flag to determine if energy is calculated\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.DefSQGVortex","page":"List of Functions","title":"QGDipoles.DefSQGVortex","text":"DefSQGVortex(grid; U=1, ℓ=1, R=[Inf,Inf], β=0, x₀=[0,0], α=0, M=12, tol=1e-6, K₀=nothing, a₀=nothing, CalcVelocity=false, CalcVorticity=false, CalcEnergy=false)\n\nDefines an SQGVortex solution structure using the given inputs\n\nArguments:\n\ngrid: grid structure\n\nKeyword arguments:\n\nU: Vortex speed\nℓ: Vortex radius\nR: Rossby radius\nβ: background PV gradient\nx₀: Vortex position\nα: Direction of vortex propagation\nM: number of coefficients in Zernike expansion\ntol: maximum error in solution evaluation\nK₀: initial guess for eigenvalue\na₀: initial guess for coefficients\nCalcVelocity: flag to determine if velocity is calculated\nCalcVorticity: flag to determine if vorticity is calculated\nCalcEnergy: flag to determine if energy is calculated\n\n\n\n\n\nDefSQGVortex(grid, params)\n\nDefines an SQGVortex solution structure using the given inputs\n\nArguments:\n\ngrid: grid structure\nparams: vortex parameters, LQGParams structure\n\n\n\n\n\n","category":"function"},{"location":"Functions/#Shared","page":"List of Functions","title":"Shared","text":"","category":"section"},{"location":"Functions/","page":"List of Functions","title":"List of Functions","text":"UpdateParams\nUpdateVortex","category":"page"},{"location":"Functions/#QGDipoles.UpdateParams","page":"List of Functions","title":"QGDipoles.UpdateParams","text":"UpdateParams(params::LQGParams; kwargs...)\n\nCreates an LQGParams structure by replacing parameters in params with the given keywords\n\nArguments:\n\nparams: LQGParams parameter structure\n\nKeyword arguments:\n\nkwargs...: keyword arguments for DefLQGParams\n\n\n\n\n\nUpdateParams(params::SQGParams; kwargs...)\n\nCreates an SQGParams structure by replacing parameters in params with the given keywords\n\nArguments:\n\nparams: SQGParams parameter structure\n\nKeyword arguments:\n\nkwargs...: keyword arguments for DefSQGParams\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.UpdateVortex","page":"List of Functions","title":"QGDipoles.UpdateVortex","text":"UpdateVortex(grid, vortex::LQGVortex; kwargs...)\n\nCreates an LQGVortex structure by replacing parameters in vortex.params with the given keywords\n\nArguments:\n\ngrid: grid structure\nvortex: LQGVortex structure\n\nKeyword arguments:\n\nkwargs...: keyword arguments for DefLQGParams\n\n\n\n\n\nUpdateVortex(grid, vortex::SQGVortex; kwargs...)\n\nCreates an SQGVortex structure by replacing parameters in vortex.params with the given keywords\n\nArguments:\n\ngrid: grid structure\nvortex: SQGVortex structure\n\nKeyword arguments:\n\nkwargs...: keyword arguments for DefSQGParams\n\n\n\n\n\n","category":"function"},{"location":"Functions/#High-Level-Functions","page":"List of Functions","title":"High-Level Functions","text":"","category":"section"},{"location":"Functions/#LQG-2","page":"List of Functions","title":"LQG","text":"","category":"section"},{"location":"Functions/","page":"List of Functions","title":"List of Functions","text":"CreateModonLQG\nCreateLCD\nCreateLRD","category":"page"},{"location":"Functions/#QGDipoles.CreateModonLQG","page":"List of Functions","title":"QGDipoles.CreateModonLQG","text":"CreateModonLQG(grid; U=1, ℓ=1, R=Inf, β=0, ActiveLayers=1, x₀=[0, 0], α=0, M=8, tol=1e-6, K₀=nothing, a₀=nothing)\n\nHigh level wrapper function for calculating ψ and q for the Layered QG model using given parameters\n\nArguments:\n\ngrid: grid structure containing x, y, and Krsq\n\nKeyword arguments:\n\n(U, ℓ): vortex speed and radius, Numbers (default: (1, 1))\n(R, β): Rossby radii and (y) PV gradients in each layer, Numbers or Vectors, (default: (Inf, 0))\nActiveLayers: vector of 1s or 0s where 1 denotes an active layer, Number or Vector, (default: [1,..,1])\nx₀: position of vortex center, vector (default: [0, 0])\nα: initial angle of vortex, Number (default: 0)\nM: number of coefficient to solve for, Integer (default: 8)\ntol: error tolerance passed to QuadGK and NLSolve functions, Number (default: 1e-6)\nK₀, a₀: initial guesses for K and a, Arrays or nothings (default: nothing)\n\nNote: provide values of K₀ and a₀ for active layers ONLY.\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.CreateLCD","page":"List of Functions","title":"QGDipoles.CreateLCD","text":"CreateLCD(grid; U=1, ℓ=1, x₀=[0, 0], α=0)\n\nHigh level wrapper function for calculating ψ and q for the Lamb-Chaplygin dipole using given parameters\n\nArguments:\n\ngrid: grid structure containing x, y, and Krsq\n\nKeyword arguments:\n\n(U, ℓ): vortex speed and radius, Numbers (default: (1, 1))\nx₀: position of vortex center, vector (default: [0, 0])\nα: initial angle of vortex, Number (default: 0)\n\nNote: This function uses the analytic solution for the LCD to calculate ψ and q.\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.CreateLRD","page":"List of Functions","title":"QGDipoles.CreateLRD","text":"CreateLRD(grid; U=1, ℓ=1, R=Inf, β=0, x₀=[0, 0], α=0)\n\nHigh level wrapper function for calculating ψ and q for the Larichev-Reznik dipole using given parameters\n\nArguments:\n\ngrid: grid structure containing x, y, and Krsq\n\nKeyword arguments:\n\n(U, ℓ): vortex speed and radius, Numbers (default: (1, 1))\n(R, β): Rossby radii and (y) PV gradient, Numbers, (default: (Inf, 0))\nx₀: position of vortex center, vector (default: [0, 0])\nα: initial angle of vortex, Number (default: 0)\n\nNote: This function uses the analytic solution for the LRD to calculate ψ and q.\n\n\n\n\n\n","category":"function"},{"location":"Functions/#SQG-2","page":"List of Functions","title":"SQG","text":"","category":"section"},{"location":"Functions/","page":"List of Functions","title":"List of Functions","text":"CreateModonSQG\nEval_ψ_SQG\nEval_q_SQG\nEval_b_SQG\nEval_w_SQG","category":"page"},{"location":"Functions/#QGDipoles.CreateModonSQG","page":"List of Functions","title":"QGDipoles.CreateModonSQG","text":"CreateModonSQG(grid; U=1, ℓ=1, R=[Inf, Inf], β=0, x₀=[0, 0], α=0, M=12, tol=1e-6, K₀=nothing, a₀=nothing)\n\nHigh level wrapper function for calculating ψ and b for the SQG model using given parameters\n\nArguments:\n\ngrid: grid structure containing x, y, and Krsq\n\nKeyword arguments:\n\n(U, ℓ): vortex speed and radius, Numbers (default: (1, 1))\nR: vector of R R, Vector (default: [Inf, Inf])\nβ: beta-plane (y) PV gradient, Number (default: 0)\nx₀: position of vortex center, vector (default: [0, 0])\nα: initial angle of vortex, Number (default: 0)\nM: number of coefficient to solve for, Integer (default: 12)\ntol: error tolerance passed to QuadGK and NLSolve functions, Number (default: 1e-6)\nK₀, a₀: initial guesses for K and a, Arrays or nothings (default: nothing)\n\nNote: Here R is the baroclinic Rossby radius, R = NH/f, and R' = R₀²/R where R₀ is the barotropic Rossby radius, R₀ = √(gH)/f. For infinite depth, R' = g/(fN).\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.Eval_ψ_SQG","page":"List of Functions","title":"QGDipoles.Eval_ψ_SQG","text":"Eval_ψ_SQG(grid, ψ; z=[0], U=1, R=[Inf, Inf], β=0)\n\nEvaluates ψ at specified depths, z  -R 0, for the SQG problem\n\nArguments:\n\ngrid: grid structure containing x, y, and Krsq\nψ: surface streamfunction, calculated using Calc_ψb or CreateModonSQG\n\nKeyword arguments:\n\nz: vector of depths (default: [0])\nU: vortex speed, Number (default: 1)\nR: vector of R R, Vector (default: [Inf, Inf])\nβ: beta-plane (y) PV gradient, Number (default: 0)\n\nNote: Here R is the baroclinic Rossby radius, R = NHf, and R = R₀²R where R₀ is the barotropic Rossby radius, R₀ = (gH)f. For infinite depth, R = g(fN).\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.Eval_q_SQG","page":"List of Functions","title":"QGDipoles.Eval_q_SQG","text":"Eval_q_SQG(grid, ψ; z=[0], U=1, R=[Inf, Inf], β=0)\n\nEvaluates q at specified depths, z  -R 0, for the SQG problem\n\nArguments:\n\ngrid: grid structure containing x, y, and Krsq\nψ: surface streamfunction, calculated using Calc_ψb or CreateModonSQG\n\nKeyword arguments:\n\nz: vector of depths (default: [0])\nU: vortex speed, Number (default: 1)\nR: vector of R R, Vector (default: [Inf, Inf])\nβ: beta-plane (y) PV gradient, Number (default: 0)\n\nNote: Here R is the baroclinic Rossby radius, R = NHf, and R = R₀²R where R₀ is the barotropic Rossby radius, R₀ = (gH)f. For infinite depth, R = g(fN).\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.Eval_b_SQG","page":"List of Functions","title":"QGDipoles.Eval_b_SQG","text":"Eval_b_SQG(grid, ψ; z=[0], U=1, R=[Inf, Inf], β=0)\n\nEvaluates b at specified depths, z  -R 0, for the SQG problem\n\nArguments:\n\ngrid: grid structure containing x, y, and Krsq\nψ: surface streamfunction, calculated using Calc_ψb or CreateModonSQG\n\nKeyword arguments:\n\nz: vector of depths (default: [0])\nU: vortex speed, Number (default: 1)\nR: vector of R R, Vector (default: [Inf, Inf])\nβ: beta-plane (y) PV gradient, Number (default: 0)\n\nNote: Here R is the baroclinic Rossby radius, R = NHf, and R = R₀²R where R₀ is the barotropic Rossby radius, R₀ = (gH)f. For infinite depth, R = g(fN).\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.Eval_w_SQG","page":"List of Functions","title":"QGDipoles.Eval_w_SQG","text":"Eval_w_SQG(grid, ψ; z=[0], U=1, R=[Inf, Inf], β=0)\n\nEvaluates N²w at specified depths, z  -R 0, for the SQG problem using N²w = -Jψ + Uy b\n\nArguments:\n\ngrid: grid structure containing x, y, and Krsq\nψ: surface streamfunction, calculated using Calc_ψb or CreateModonSQG\n\nKeyword arguments:\n\nz: vector of depths (default: [0])\nU: vortex speed, Number (default: 1)\nR: vector of R R, Vector (default: [Inf, Inf])\nβ: beta-plane (y) PV gradient, Number (default: 0)\n\nNote: Here R is the baroclinic Rossby radius, R = NHf, and R = R₀²R where R₀ is the barotropic Rossby radius, R₀ = (gH)f. For infinite depth, R = g(fN).\n\nNote: this function is not accurate at the surface as b is discontinuous there. Instead use w = -Uηx where η = fψg is the surface elevation, or w = 0 if R = .\n\n\n\n\n\n","category":"function"},{"location":"Functions/#Utilities","page":"List of Functions","title":"Utilities","text":"","category":"section"},{"location":"Functions/","page":"List of Functions","title":"List of Functions","text":"CreateGrid\nCalc_uv\nCalc_∇\nCalc_ζ","category":"page"},{"location":"Functions/#QGDipoles.CreateGrid","page":"List of Functions","title":"QGDipoles.CreateGrid","text":"CreateGrid(Nx, Ny, Lx, Ly; cuda=false)\n\nDefine the numerical grid as a GridStruct\n\nArguments:\n\nNx, Ny: number of gridpoints in x and y directions, Integers\nLx, Ly: x and y domains, either vectors of endpoints or lengths, Vectors or Numbers\n\nKeyword arguments:\n\ncuda: true; use CUDA CuArray for fields (default: false)\n\n\n\n\n\nCreateGrid(; Nx=512, Ny=512, Lx=[-5,5], Ly=[-5,5], cuda=false)\n\nDefine the numerical grid as a GridStruct using a keyword-based method\n\nKeyword arguments:\n\nNx, Ny: number of gridpoints in x and y directions, Integers\nLx, Ly: x and y domains, either vectors of endpoints or lengths, Vectors or Numbers\ncuda: true; use CUDA CuArray for fields (default: false)\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.Calc_uv","page":"List of Functions","title":"QGDipoles.Calc_uv","text":"Calc_uv(grid, ψ)\n\nCalculate the velocity fields from ψ using (u v) = (-ψy ψx)\n\nArguments:\n\ngrid: grid structure containing kr and l\nψ: streamfunction, Array\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.Calc_∇","page":"List of Functions","title":"QGDipoles.Calc_∇","text":"Calc_∇(grid, f)\n\nCalculate the gradient f for a given field f\n\nArguments:\n\ngrid: grid structure containing kr and l\nf: function, Array\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.Calc_ζ","page":"List of Functions","title":"QGDipoles.Calc_ζ","text":"Calc_ζ(grid, ψ)\n\nCalculate the vertical vorticity using ζ = vx - uy = ²ψ\n\nArguments:\n\ngrid: grid structure containing Krsq\nψ: streamfunction, Array\n\n\n\n\n\n","category":"function"},{"location":"Functions/#Diagnostics","page":"List of Functions","title":"Diagnostics","text":"","category":"section"},{"location":"Functions/#LQG-3","page":"List of Functions","title":"LQG","text":"","category":"section"},{"location":"Functions/","page":"List of Functions","title":"List of Functions","text":"EnergyLQG\nEnstrophyLQG","category":"page"},{"location":"Functions/#QGDipoles.EnergyLQG","page":"List of Functions","title":"QGDipoles.EnergyLQG","text":"EnergyLQG(grid, ψ; R=Inf, H=[1])\n\nCalculates the kinetic and potential energy for the LQG system\n\nArguments:\n\ngrid: grid structure containing Krsq\nψ: streamfunction in each layer, Array or CuArray\n\nKeyword arguments:\n\nR: Rossby radius in each layer, Number or Vector (default: Inf)\nH: Thickness of each layer, Number or Vector (default: [1])\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.EnstrophyLQG","page":"List of Functions","title":"QGDipoles.EnstrophyLQG","text":"EnstrophyLQG(grid, q; H=[1])\n\nCalculates the enstrophy for the LQG system\n\nArguments:\n\ngrid: grid structure containing Krsq\nq: potential vorticity anomaly in each layer, Array or CuArray\n\nKeyword arguments:\n\nH: Thickness of each layer, Number or Vector (default: [1])\n\n\n\n\n\n","category":"function"},{"location":"Functions/#SQG-3","page":"List of Functions","title":"SQG","text":"","category":"section"},{"location":"Functions/","page":"List of Functions","title":"List of Functions","text":"EnergySQG","category":"page"},{"location":"Functions/#QGDipoles.EnergySQG","page":"List of Functions","title":"QGDipoles.EnergySQG","text":"EnergySQG(grid, ψ, b; R′)\n\nCalculates the energies for the SQG system; the total domain integrated energy and the surface potential energy\n\nArguments:\n\ngrid: grid structure containing Krsq\nψ: surface streamfunction, Array or CuArray\nb: surface buoyancy, , Array or CuArray\n\nKeyword arguments:\n\nR′: reduced barotropic Rossby radius, Number (default: Inf)\n\nNote: the surface potential energy is sometimes referred to as the generalised enstrophy or the buoyancy variance.\n\n\n\n\n\n","category":"function"},{"location":"Functions/#Low-Level-Functions","page":"List of Functions","title":"Low-Level Functions","text":"","category":"section"},{"location":"Functions/#LQG-4","page":"List of Functions","title":"LQG","text":"","category":"section"},{"location":"Functions/","page":"List of Functions","title":"List of Functions","text":"BuildLinSysLQG\nApplyPassiveLayers\nIncludePassiveLayers\nCalc_ψq","category":"page"},{"location":"Functions/#QGDipoles.BuildLinSysLQG","page":"List of Functions","title":"QGDipoles.BuildLinSysLQG","text":"BuildLinSysLQG(M, λ, μ; tol=1e-6)\n\nBuilds the terms in the inhomogeneous eigenvalue problem; A, B, c, d for the LQG problem\n\nArguments:\n\nM: number of coefficient to solve for, Integer\nλ: ratio of vortex radius to Rossby radius in each layer, Number or Vector\nμ: nondimensional (y) vorticity gradient in each layer, Number or Vector\n\nKeyword arguments:\n\ntol: error tolerance for QuadGK via JJ_int, Number (default: 1e-6)\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.ApplyPassiveLayers","page":"List of Functions","title":"QGDipoles.ApplyPassiveLayers","text":"ApplyPassiveLayers(A, B, c, d, ActiveLayers)\n\nRemoves rows and columns corresponding to passive layers from the system\n\nArguments:\n\nA, B, c, d: inhomogeneous eigenvalue problem terms, Arrays\nActiveLayers: vector of 1s or 0s where 1 denotes an active layer, Number or Vector\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.IncludePassiveLayers","page":"List of Functions","title":"QGDipoles.IncludePassiveLayers","text":"IncludePassiveLayers(K, a, ActiveLayers)\n\nIncludes columns corresponding to passive layers in the eigenvalue and coefficient arrays\n\nArguments:\n\nK, a: eigenvalue and coefficient arrays describing system solution, Arrays\nActiveLayers: vector of 1s or 0s where 1 denotes an active layer, Number or Vector\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.Calc_ψq","page":"List of Functions","title":"QGDipoles.Calc_ψq","text":"Calc_ψq(grid, a; U, ℓ, R, β, x₀=[0, 0], α=0)\n\nCalculate ψ and q in a layered QG model using coefficients and vortex parameters\n\nArguments:\n\ngrid: grid structure containing x, y, and Krsq\na: M x N array of coefficients, Array\n\nKeyword arguments:\n\n(U, ℓ): vortex speed and radius, Numbers (default: (1, 1))\n(R, β): Rossby radii and (y) PV gradients in each layer, Numbers or Vectors (default: (Inf, 0))\nx₀: position of vortex center, vector (default: [0, 0])\nα: initial angle of vortex, Number (default: 0)\n\n\n\n\n\n","category":"function"},{"location":"Functions/#SQG-4","page":"List of Functions","title":"SQG","text":"","category":"section"},{"location":"Functions/","page":"List of Functions","title":"List of Functions","text":"BuildLinSysSQG\nCalc_ψb","category":"page"},{"location":"Functions/#QGDipoles.BuildLinSysSQG","page":"List of Functions","title":"QGDipoles.BuildLinSysSQG","text":"BuildLinSysSQG(M, λ, μ; tol=1e-6)\n\nBuilds the terms in the inhomogeneous eigenvalue problem; A, B, c, d for the SQG problem\n\nArguments:\n\nM: number of coefficient to solve for, Integer\nλ: ratio of vortex radius to Rossby radius in each layer, Number or Vector\nμ: nondimensional (y) vorticity gradient in each layer, Number or Vector\n\nKeyword arguments:\n\ntol: error tolerance for QuadGK via JJ_int, Number (default: 1e-6)\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.Calc_ψb","page":"List of Functions","title":"QGDipoles.Calc_ψb","text":"Calc_ψb(grid, a; U, ℓ, R, β, x₀=[0, 0], α=0)\n\nCalculate SQG fields ψ and b using coefficients and vortex parameters\n\nArguments:\n\ngrid: grid structure containing x, y, and Krsq\na: M x 1 array of coefficients, Array\n\nKeyword arguments:\n\n(U, ℓ): vortex speed and radius, Numbers (default: 1)\nR: vector of R R, Vector (default: [Inf, Inf])\nβ: beta-plane (y) PV gradient, Number (default: 1)\nx₀: position of vortex center, vector (default: [0, 0])\nα: initial angle of vortex, Number (default: 0)\n\nNote: Here R is the baroclinic Rossby radius, R = NH/f, and R' = R₀²/R where R₀ is the barotropic Rossby radius, R₀ = √(gH)/f. For infinite depth, R' = g/(fN).\n\n\n\n\n\n","category":"function"},{"location":"Functions/#Shared-2","page":"List of Functions","title":"Shared","text":"","category":"section"},{"location":"Functions/","page":"List of Functions","title":"List of Functions","text":"SolveInhomEVP","category":"page"},{"location":"Functions/#QGDipoles.SolveInhomEVP","page":"List of Functions","title":"QGDipoles.SolveInhomEVP","text":"SolveInhomEVP(A, B, c, d; K₀=nothing, a₀=nothing, tol=1e-6, method=:eigensolve, m=2, warn=true)\n\nSolves the inhomogeneous eigenvalue problem using nonlinear root finding\n\nArguments:\n\nA, B, c, d: inhomogeneous eigenvalue problem terms, Arrays\n\nKeyword arguments:\n\nK₀, a₀: initial guesses for K and a, Arrays or nothings (default: nothing)\ntol: error tolerance for nlsolve, Number (default: 1e-6)\nmethod: :eigensolve or :nlsolve, for N  1 :nlsolve is used automatically (default: :eigensolve)\nm: exponent of K in eignevalue problem (default: 2)\nwarn: if true displays warning if solution includes unextracted passive layers (default: true)\n\n\n\n\n\n","category":"function"},{"location":"Functions/#Extras","page":"List of Functions","title":"Extras","text":"","category":"section"},{"location":"Functions/#Monopoles","page":"List of Functions","title":"Monopoles","text":"","category":"section"},{"location":"Functions/","page":"List of Functions","title":"List of Functions","text":"CreateRankine\nCreate1LMonopole\nCreateLQGMonopole\nInvertVorticity1LQG\nInvertVorticityLQG","category":"page"},{"location":"Functions/#QGDipoles.CreateRankine","page":"List of Functions","title":"QGDipoles.CreateRankine","text":"CreateRankine(grid; ℓ=1, Γ=2π, x₀=[0, 0])\n\nCalculates the Rankine vortex for a 1 layer system. This vortex appears as a point vortex in the far field but consists of solid body rotation within the region r  ℓ.\n\nArguments:\n\ngrid: grid structure containing x, y, and Krsq\n\nKeyword arguments:\n\nℓ: vortex speed and radius, Numbers (default: 1)\nΓ: vortex circulation (default: 2π)\nx₀: position of vortex center, vector (default: [0, 0])\n\nNote: This function outputs (u v) directly since the solution has discontinuous velocity at the vortex boundary, r = ℓ, so derivatives evaluated with Fourier transforms exhibit Gibbs phenomenon.\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.Create1LMonopole","page":"List of Functions","title":"QGDipoles.Create1LMonopole","text":"Create1LMonopole(grid; ℓ=1, Γ=2π, R=Inf, x₀=[0, 0])\n\nCalculates a monopolar vortex satisfying a Long's model assumption q = F(ψ) where q = ²-1R²ψ. We take F(z) = -(K²+1R²)(z-z₀) for r  ℓ and F(z) = 0 for r  ℓ and z₀ = ψ(r=ℓ). These solutions exist only on an f-plane (β = 0).\n\nArguments:\n\ngrid: grid structure containing x, y, and Krsq\n\nKeyword arguments:\n\nℓ: vortex speed and radius, Numbers (default: 1)\nΓ: vortex circulation (default: 2π)\nR: Rossby radius (default: Inf)\nx₀: position of vortex center, vector (default: [0, 0])\n\nNote: This vortex has a continuous vorticity distribution so calculating (u, v) from ψ with Fourier transforms will work. This function outputs (u, v) from the analytical expressions for consistency with CreateRankine.\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.CreateLQGMonopole","page":"List of Functions","title":"QGDipoles.CreateLQGMonopole","text":"CreateLQGMonopole(grid; ℓ=1, E=1, R=Inf, x₀=[0, 0])\n\nCalculates a monopolar vortex in the LQG model using a numerical approach. We assume that qⱼ + βⱼ = Fⱼ(ψⱼ + Uy) and write Fⱼ(z) = -Kⱼ² z + Eⱼ. Expanding the expression gives qⱼ + βⱼ = -Kⱼ²(ψⱼ + Uy) + Eⱼ which by linearity can be split into a dipole equation qⱼ + βⱼ = -Kⱼ²(ψⱼ + Uy) and a monopole equation qⱼ = Eⱼ. Outside the vortex, we take qⱼ = 0.\n\nArguments:\n\ngrid: grid structure containing x, y, and Krsq\n\nKeyword arguments:\n\nℓ: vortex speed and radius, Numbers (default: 1)\nE: vector of Eⱼ values, Number or Vector (default: [1, ... , 1])\nR: Rossby radius (default: Inf)\nx₀: position of vortex center, vector (default: [0, 0])\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.InvertVorticity1LQG","page":"List of Functions","title":"QGDipoles.InvertVorticity1LQG","text":"InvertVorticity1LQG(grid, q; R=Inf)\n\nThis function inverts the potential vorticity relation q = ²-1R²ψ for 1-layer QG\n\nArguments:\n\ngrid: grid structure containing x, y, and Krsq\nq: potential vorticity field, Array\n\nKeyword arguments:\n\nR: Rossby radius (default: Inf)\n\nNote: This function is designed to be used for creating periodic streamfunctions using the vorticity fields generated by Create1LMonopole. It does not support multi-layer QG and is only valid on an f-plane (β = 0).\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.InvertVorticityLQG","page":"List of Functions","title":"QGDipoles.InvertVorticityLQG","text":"InvertVorticityLQG(grid, q; R=Inf)\n\nThis function inverts the potential vorticity relation q = ΔN ψ for the LQG model\n\nArguments:\n\ngrid: grid structure containing x, y, and Krsq\nq: potential vorticity field, Array\n\nKeyword arguments:\n\nR: Rossby radius, Number or Vector (default: Inf)\n\n\n\n\n\n","category":"function"},{"location":"Functions/#Internal","page":"List of Functions","title":"Internal","text":"","category":"section"},{"location":"Functions/","page":"List of Functions","title":"List of Functions","text":"QGDipoles.A_func\nQGDipoles.B_func\nQGDipoles.JJ_int\nQGDipoles.InhomEVP_F!\nQGDipoles.OrthogSpace\nQGDipoles.ZernikeR\nQGDipoles.GridStruct\nQGDipoles.ΔNCalc\nQGDipoles.CartesianGrid\nQGDipoles.PolarGrid\nQGDipoles.AreaInteg2","category":"page"},{"location":"Functions/#QGDipoles.A_func","page":"List of Functions","title":"QGDipoles.A_func","text":"A_func(ξ, λ, μ)\n\nEvaluates the matrix function A(ξ λ μ) = K(ξ) K(ξ) + D(μ)¹ ξ¹\n\nArguments:\n\nξ: point in 0 ), Number\nλ: ratio of vortex radius to Rossby radius in each layer, Number or Vector\nμ: nondimensional (y) vorticity gradient in each layer, Number or Vector\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.B_func","page":"List of Functions","title":"QGDipoles.B_func","text":"B_func(ξ, λ, μ)\n\nEvaluates the matrix function B(ξ λ μ) = K(ξ) + D(μ)¹ ξ¹\n\nArguments:\n\nξ: point in 0 ), Number\nλ: ratio of vortex radius to Rossby radius in each layer, Number or Vector\nμ: nondimensional (y) vorticity gradient in each layer, Number or Vector\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.JJ_int","page":"List of Functions","title":"QGDipoles.JJ_int","text":"JJ_int(F, j, k, tol=1e-6)\n\nEvaluates the integral I = _0^ F(ξ) J_2j+2(ξ) J_2k+2(ξ) mathrmdξ\n\nArguments:\n\nF: function to integrate, typically A_func or B_func, Function\nj: first Bessel function index, Integer\nk: second Bessel function index, Integer\ntol: error tolerance for QuadGK, Number (default: 1e-6)\n\nNote: This integral is performed by deforming the contour of integration into the complex plane where the Bessel function decays exponentially in the imaginary direction.\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.InhomEVP_F!","page":"List of Functions","title":"QGDipoles.InhomEVP_F!","text":"InhomEVP_F!(F, J, x, A, B, c, d, e)\n\nCalculates the function F and it's derivatives, J, at a given point x\n\nArguments:\n\nF, J: values of F and it's derivatives, updated by function\nx: evaluation point, Array\nA, B, c: inhomogeneous eigenvalue problem terms, Arrays\ne: basis spanning the space perpendicular to the dn, Array\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.OrthogSpace","page":"List of Functions","title":"QGDipoles.OrthogSpace","text":"OrthogSpace(v)\n\nExtends the input to an orthonormal basis over R^n using the Gram-Schmidt method\n\nArguments:\n\nv: array with vectors as columns, Array\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.ZernikeR","page":"List of Functions","title":"QGDipoles.ZernikeR","text":"ZernikeR(n, x)\n\nDefine the Zernike radial function using the jacobi function from SpecialFunctions\n\nArguments:\n\nn: order, Integer\nx: evaluation point, Number or Array\n\nNote: this function is defined on -1 1 and is set to 0 for x  1\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.GridStruct","page":"List of Functions","title":"QGDipoles.GridStruct","text":"GridStruct\n\nStores the grid variables in physical and Fourier space\n\nFields:\n\nx, y: x and y points in physical space, Ranges\nkr, l: x and y points in Fourier space, Arrays\nKrsq: kr²+l² in Fourier space, Array\n\n\n\n\n\n","category":"type"},{"location":"Functions/#QGDipoles.ΔNCalc","page":"List of Functions","title":"QGDipoles.ΔNCalc","text":"ΔNCalc(K², R, β, U=1)\n\nDefines the Δ_N(β) matrix used to invert for ψ and q\n\nArguments:\n\nK²: value of k²+l² in Fourier space, Array\n(R, β): Rossby radii and (y) PV gradients in each layer, Numbers or Vectors\nU: vortex speed, Number (default: 1)\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.CartesianGrid","page":"List of Functions","title":"QGDipoles.CartesianGrid","text":"CartesianGrid(grid)\n\nFormats the (x y) ranges from grid as two-dimensional Arrays\n\nArguments:\n\ngrid: grid structure containing kr and l\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.PolarGrid","page":"List of Functions","title":"QGDipoles.PolarGrid","text":"PolarGrid(x, y, x₀)\n\nCalculates the polar coordinates from (x, y) as two-dimensional Array centred on x₀\n\nArguments:\n\nx, y: 2D Arrays for x and y, created using CartesianGrid\nx₀: Vector\n\n\n\n\n\n","category":"function"},{"location":"Functions/#QGDipoles.AreaInteg2","page":"List of Functions","title":"QGDipoles.AreaInteg2","text":"AreaInteg2(f, grid)\n\nCalculates the integral I = _A f^2 mathrmdA where A is the 2D domain described by grid.\n\nArguments:\n\nf: input Array in real or Fourier space\ngrid: grid structure\n\nNote: f can be entered in real space or Fourier space, we use the rfft function to calculate the Fourier transform so array sizes can distinguish the two.\n\n\n\n\n\n","category":"function"},{"location":"Functions/#Base-and-RecipesBase","page":"List of Functions","title":"Base & RecipesBase","text":"","category":"section"},{"location":"Functions/","page":"List of Functions","title":"List of Functions","text":"Base.summary\nBase.show\nRecipesBase.apply_recipe","category":"page"},{"location":"Functions/#Base.summary","page":"List of Functions","title":"Base.summary","text":"Base.summary function for custom type GridStruct\n\n\n\n\n\nBase.summary\n\nSummary method for custom type LQGParams\n\n\n\n\n\nBase.summary\n\nSummary method for custom type LQGVortex\n\n\n\n\n\nBase.summary\n\nSummary method for custom type SQGParams\n\n\n\n\n\nBase.summary\n\nSummary method for custom type SQGVortex\n\n\n\n\n\n","category":"function"},{"location":"Functions/#Base.show","page":"List of Functions","title":"Base.show","text":"Base.show function for custom type GridStruct\n\n\n\n\n\nBase.show\n\nShow method for custom type LQGParams\n\n\n\n\n\nBase.show\n\nShow method for custom type LQGVortex\n\n\n\n\n\nBase.show\n\nShow method for custom type SQGParams\n\n\n\n\n\nBase.show\n\nShow method for custom type SQGVortex\n\n\n\n\n\n","category":"function"},{"location":"Functions/#RecipesBase.apply_recipe","page":"List of Functions","title":"RecipesBase.apply_recipe","text":"f(grid, F::AbstractArray; layer=1)\n\nRecipe for plotting field F on grid\n\nArguments:\n\ngrid: grid object\nF: field, may have mltiple layers\n\nKeyword arguments:\n\nlayer: layer to plot (default: 1)\n\n\n\n\n\nf(grid, F::CuArray; layer=1)\n\nRecipe for plotting field F on grid\n\nArguments:\n\ngrid: grid object\nF: field, may have mltiple layers\n\nKeyword arguments:\n\nlayer: layer to plot (default: 1)\n\n\n\n\n\n","category":"function"},{"location":"#QGDipoles.jl","page":"Home","title":"QGDipoles.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation and examples for QGDipoles.jl by Matthew N. Crowe.","category":"page"},{"location":"#What-is-QGDipoles.jl?","page":"Home","title":"What is QGDipoles.jl?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QGDipoles.jl is a Julia package which provides a series of functions that allow users to easily generate dipolar vortex solutions to two of the most commonly used QG models; the multi-layer QG (LQG) system and the surface QG (SQG) system. Solutions for the three-dimensional quasi-geostrophic model and magneto-quasi-geostrophic model will be implemented in the future.","category":"page"},{"location":"","page":"Home","title":"Home","text":"QGDipoles.jl is intended for use by those researching vortex dynamics in strongly rotating flows, in particular for researchers in physical oceanography and atmospheric dynamics. It may be used for semi-analytical studies of steady vortex solutions or to initialise a simulation with a steadily propagating, balanced vortex. These vortex solutions may be used as initial conditions in full primitive equation models as well as QG models since they exist in QG balance so will not generate strong initial transients.","category":"page"},{"location":"","page":"Home","title":"Home","text":"QGDipoles.jl is designed to be consistent with the framework of GeophysicalFlows.jl[4], a Julia package that contains modules for running LQG and SQG simulations on CPUs or GPUs. As such, QGDipoles.jl accepts grid inputs generated using the TwoDGrid function from FourierFlows.jl and can generate solution arrays on both CPUs and GPUs using CUDA.jl. However, FourierFlows.jl and GeophysicalFlows.jl are NOT required to use this package as an alternative grid structure is available (created using CreateGrid), which uses the same field names as the eqivalent FourierFlows.jl function.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Full documentation exists with examples covering a range of LQG and SQG solutions and demonstrating how QGDipoles.jl may be integrated with GeophysicalFlows.jl.","category":"page"},{"location":"#How-does-QGDipoles.jl-work?","page":"Home","title":"How does QGDipoles.jl work?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is based on the semi-analytic theory of dipolar vortices derived in Johnson & Crowe 2023[1] and Crowe & Johnson 2023[2] for SQG solutions and Crowe & Johnson 2024[3] for LQG solutions. Details of the numerical method and problem parameters can be found on the Methodology page. This code consists of an updated version of the MATLAB code released as supplementary material with Crowe & Johnson 2024[3] and incorporates (unreleased) functions for the SQG problem. For those interested in the original (LQG only) implementation, it can be found here.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[1]: Johnson, E. R., and M. N. Crowe, 2023, Oceanic dipoles in a surface quasigeostrophic model, J. Fluid Mech., 958, R2.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[2]: Crowe, M. N., and E. R. Johnson, 2023, The evolution of surface quasi-geostrophic modons on sloping topography, J. Fluid. Mech., 970, A10.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[3]: Crowe, M. N., and E. R. Johnson, 2024, Modon solutions in an N-layer quasi-geostrophic model, J. Fluid. Mech., 994, R1.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[4]: Constantinou et al., 2021, GeophysicalFlows.jl: Solvers for geophysical fluid dynamics problems in periodic domains on CPUs & GPUs, JOSS, 6(60), 3053.","category":"page"},{"location":"Installation/#Installation-Instructions","page":"Installation","title":"Installation Instructions","text":"","category":"section"},{"location":"Installation/","page":"Installation","title":"Installation","text":"Installing QGDipoles.jl is fairly straightforward and can be done using the Julia package manager. Note that QGDipoles is not (currently) listed as a Julia package so cannot be installed using ] add QGDipoles. It is recommended to create a new environment for each project and install any new packages to that environment. ","category":"page"},{"location":"Installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"Installation/","page":"Installation","title":"Installation","text":"Installation may be done using the package manager directly by typing ] at the Julia REPL and entering the following:","category":"page"},{"location":"Installation/","page":"Installation","title":"Installation","text":"add https://github.com/mncrowe/QGDipoles.jl.git\ninstantiate","category":"page"},{"location":"Installation/","page":"Installation","title":"Installation","text":"Alternatively, you may import the package manager and install by entering the following directly into the Julia REPL:","category":"page"},{"location":"Installation/","page":"Installation","title":"Installation","text":"import Pkg\nPkg.add(url=\"https://github.com/mncrowe/QGDipoles.jl\")\nPkg.instantiate()","category":"page"},{"location":"Installation/","page":"Installation","title":"Installation","text":"This package is not compatible with versions of Julia earlier than 1.10 due to the eachslice function.","category":"page"},{"location":"Installation/#Dependencies","page":"Installation","title":"Dependencies","text":"","category":"section"},{"location":"Installation/","page":"Installation","title":"Installation","text":"This package requires the following dependencies:","category":"page"},{"location":"Installation/","page":"Installation","title":"Installation","text":"FFTW (v1.8.0)\nJacobi (v0.7.0)\nLinearAlgebra\nNLsolve (v4.5.1)\nQuadGK (v2.9.4)\nSpecialFunctions (v2.4.0)\nCUDA (v5.4.3)\nRecipesBase (v1.3.4)","category":"page"},{"location":"Installation/","page":"Installation","title":"Installation","text":"The specified versions are confirmed to work and earlier/later versions may also work. These packages will be automatically installed with QGDipoles.jl and do not need to be added seperately.","category":"page"}]
}
